<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<link rel="manifest" href="./manifest.json">
<link rel="apple-touch-icon" href="./icon-192.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#08080f">
<title>colour garden</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@300;400;500&family=DM+Mono:wght@300;400&family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300&display=swap" rel="stylesheet">
<style>
  html, body, #root { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#08080f; }
  *, *::before, *::after { box-sizing: border-box; }
  textarea { -webkit-appearance: none; appearance: none; }
  textarea::placeholder { color: rgba(255,255,255,0.15); }
  textarea:focus { outline: none; }
  @keyframes slideIn { from { opacity:0; transform:translateX(30px); } to { opacity:1; transform:translateX(0); } }
  @keyframes slideUp { from { opacity:0; transform:translateY(14px); } to { opacity:1; transform:translateY(0); } }
  @keyframes slideUpMobile { from { opacity:0; transform:translateY(100%); } to { opacity:1; transform:translateY(0); } }
  @keyframes fadeIn { from { opacity:0; } to { opacity:1; } }
  @supports (padding-bottom: env(safe-area-inset-bottom)) {
    .safe-bottom { padding-bottom: env(safe-area-inset-bottom) !important; }
  }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;

const EMOTIONS = {
  joy: { color: [255, 215, 80], label: "Joy", keywords: ["happy","joy","wonderful","amazing","excited","beautiful","grateful","thankful","blessed","delight","laugh","smile","cheerful","bliss","elated","thrilled","ecstatic","celebrate","bright","sunshine","warm","glad","fantastic","great","awesome","brilliant"] },
  sadness: { color: [80, 100, 190], label: "Sadness", keywords: ["sad","cry","tears","depressed","lonely","miss","lost","grief","mourn","heartbreak","sorrow","melancholy","gloomy","down","blue","empty","hollow","pain","hurt","ache","weep","despair","hopeless","alone","abandoned","broken"] },
  anger: { color: [210, 70, 60], label: "Anger", keywords: ["angry","furious","rage","hate","frustrated","annoyed","irritated","mad","livid","outraged","hostile","bitter","resentful","fuming","seething","enraged","infuriated","aggravated","heated","irate"] },
  fear: { color: [130, 70, 160], label: "Fear", keywords: ["afraid","scared","fear","terrified","anxious","worry","nervous","panic","dread","horror","fright","uneasy","tense","paranoid","overwhelmed","vulnerable","helpless","threatened","insecure","nightmare"] },
  surprise: { color: [255, 160, 70], label: "Surprise", keywords: ["surprised","shocked","unexpected","amazed","astonished","stunned","wow","unbelievable","incredible","suddenly","bewildered","startled","speechless","revelation","discovered","realized"] },
  trust: { color: [80, 185, 150], label: "Trust", keywords: ["trust","faith","believe","reliable","honest","loyal","safe","secure","confident","depend","support","comfort","steady","stable","genuine","sincere","bond","connection","friendship"] },
  anticipation: { color: [240, 170, 190], label: "Hope", keywords: ["waiting","hope","expect","looking forward","eager","ready","upcoming","soon","plan","prepare","dream","wish","aspire","imagine","tomorrow","future","possibility","adventure","beginning"] },
  serenity: { color: [150, 200, 215], label: "Calm", keywords: ["calm","peaceful","serene","tranquil","quiet","still","gentle","soft","breathe","relax","meditation","mindful","zen","harmony","balance","rest","ease","content","soothe","float","drift","silence","nature","ocean"] },
  nostalgia: { color: [195, 160, 120], label: "Nostalgia", keywords: ["remember","memory","memories","childhood","past","used to","back then","once","ago","old","vintage","reminisce","hometown","tradition","heritage","grandma","grandpa","youth","familiar"] },
  pride: { color: [210, 175, 70], label: "Pride", keywords: ["proud","accomplished","achieved","success","victory","won","earned","triumph","milestone","progress","growth","strength","capable","powerful","mastered","overcome","conquered","excellence","honor"] },
  guilt: { color: [135, 105, 105], label: "Guilt", keywords: ["guilty","regret","sorry","mistake","wrong","fault","blame","ashamed","shame","remorse","apologize","forgive","should have","wish I","if only","failed","let down","burden","conscience"] },
  love: { color: [215, 90, 130], label: "Love", keywords: ["love","adore","cherish","darling","sweetheart","heart","passion","romance","kiss","embrace","tender","affection","intimate","devoted","soulmate","beloved","caring","warmth","together","forever","crush","butterflies"] },
  confusion: { color: [165, 145, 195], label: "Confusion", keywords: ["confused","uncertain","unsure","doubt","questioning","wonder","puzzled","perplexed","conflicted","torn","unclear","foggy","disoriented","bewildered","muddled","complicated","tangled","maze"] },
  awe: { color: [100, 90, 185], label: "Awe", keywords: ["awe","wonder","magnificent","breathtaking","majestic","vast","infinite","universe","cosmic","divine","sacred","miraculous","magical","ethereal","transcendent","sublime","profound","epic","legendary","timeless","eternal"] },
  envy: { color: [80, 155, 100], label: "Envy", keywords: ["jealous","envy","envious","covet","want","desire","compare","unfair","wish I had","inferior","inadequate","lacking","resentful"] },
  disgust: { color: [110, 135, 70], label: "Disgust", keywords: ["disgusted","gross","revolting","sick","nasty","repulsed","vile","awful","horrible","terrible","appalling","foul","wretched","sickening","cringe"] },
};

/* Audio Engine — Generative Ambient Music System */

// Emotional relationships: +1 kindred, -1 opposite, 0 neutral
const EMOTION_BONDS = {
  joy:          { kindred: ['love','pride','anticipation','surprise'], opposite: ['sadness','guilt','disgust'] },
  sadness:      { kindred: ['guilt','nostalgia','fear'], opposite: ['joy','pride','surprise'] },
  anger:        { kindred: ['disgust','envy'], opposite: ['serenity','trust','love'] },
  fear:         { kindred: ['confusion','sadness','guilt'], opposite: ['trust','pride','serenity'] },
  surprise:     { kindred: ['awe','joy','anticipation'], opposite: ['serenity','nostalgia'] },
  trust:        { kindred: ['serenity','love','pride'], opposite: ['fear','anger','envy'] },
  anticipation: { kindred: ['joy','surprise','pride'], opposite: ['nostalgia','sadness'] },
  serenity:     { kindred: ['trust','love','nostalgia'], opposite: ['anger','fear','surprise'] },
  nostalgia:    { kindred: ['sadness','serenity','love'], opposite: ['anticipation','surprise'] },
  pride:        { kindred: ['joy','trust','anticipation'], opposite: ['guilt','sadness','fear'] },
  guilt:        { kindred: ['sadness','fear','confusion'], opposite: ['pride','joy'] },
  love:         { kindred: ['joy','trust','serenity','nostalgia'], opposite: ['anger','disgust','envy'] },
  confusion:    { kindred: ['fear','surprise','guilt'], opposite: ['trust','serenity'] },
  awe:          { kindred: ['surprise','love','anticipation'], opposite: ['disgust','envy'] },
  envy:         { kindred: ['anger','disgust','guilt'], opposite: ['love','trust','awe'] },
  disgust:      { kindred: ['anger','envy'], opposite: ['love','awe','joy'] },
};

function getAffinity(emoA, emoB) {
  if (!emoA || !emoB || emoA === emoB) return 1;
  const bonds = EMOTION_BONDS[emoA];
  if (!bonds) return 0;
  if (bonds.kindred.includes(emoB)) return 0.7;
  if (bonds.opposite.includes(emoB)) return -0.8;
  return 0;
}

function createAudioEngine() {
  let ctx = null, master = null, active = false;
  // Effect chain nodes
  let verbSend = null, verbReturn = null, verbConv = null;
  let delSend = null, delNode = null, delFb = null, delFilt = null;
  let mainFilt = null, mainComp = null;
  // Pad layer: 4 detuned oscillator pairs for lush evolving pads
  let padVoices = [], padGain = null;
  // Sub-bass drone
  let subOsc = null, subGain = null, subFilt = null;
  // Texture layer: filtered noise
  let noiseNode = null, noiseGain = null, noiseFilt = null;
  // LFOs
  let lfo1 = null, lfo1Gain = null, lfo2 = null, lfo2Gain = null;
  // Generative melody state
  let melodyTimer = null, currentScale = [], currentRoot = 130.81, gardenMood = {};
  let chimeGain = null;

  // Emotion → musical scale (frequencies relative to root)
  // Each emotion gets a mode/scale that conveys its quality
  const EMOTION_SCALES = {
    joy:          { root: 261.63, intervals: [1, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8], mode: 'ionian', tempo: 4500, filterBase: 1800, padType: 'triangle', padVol: 0.018, noiseVol: 0.003 },
    sadness:      { root: 220.00, intervals: [1, 9/8, 6/5, 4/3, 3/2, 8/5, 9/5], mode: 'aeolian', tempo: 7000, filterBase: 500, padType: 'sine', padVol: 0.022, noiseVol: 0.006 },
    anger:        { root: 146.83, intervals: [1, 16/15, 6/5, 4/3, 64/45, 8/5, 9/5], mode: 'locrian', tempo: 3500, filterBase: 350, padType: 'sawtooth', padVol: 0.014, noiseVol: 0.008 },
    fear:         { root: 185.00, intervals: [1, 16/15, 6/5, 4/3, 3/2, 8/5, 9/5], mode: 'phrygian', tempo: 5500, filterBase: 450, padType: 'sine', padVol: 0.016, noiseVol: 0.010 },
    surprise:     { root: 329.63, intervals: [1, 9/8, 5/4, 45/32, 3/2, 5/3, 15/8], mode: 'lydian', tempo: 3000, filterBase: 2500, padType: 'triangle', padVol: 0.015, noiseVol: 0.004 },
    trust:        { root: 196.00, intervals: [1, 9/8, 5/4, 4/3, 3/2, 5/3, 9/5], mode: 'mixolydian', tempo: 5000, filterBase: 900, padType: 'sine', padVol: 0.020, noiseVol: 0.004 },
    anticipation: { root: 293.66, intervals: [1, 9/8, 5/4, 45/32, 3/2, 5/3, 15/8], mode: 'lydian', tempo: 3800, filterBase: 1600, padType: 'triangle', padVol: 0.016, noiseVol: 0.003 },
    serenity:     { root: 174.61, intervals: [1, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8], mode: 'ionian', tempo: 8000, filterBase: 600, padType: 'sine', padVol: 0.024, noiseVol: 0.005 },
    nostalgia:    { root: 220.00, intervals: [1, 9/8, 6/5, 4/3, 3/2, 5/3, 9/5], mode: 'dorian', tempo: 6500, filterBase: 650, padType: 'sine', padVol: 0.020, noiseVol: 0.005 },
    pride:        { root: 261.63, intervals: [1, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8], mode: 'ionian', tempo: 4000, filterBase: 1400, padType: 'triangle', padVol: 0.017, noiseVol: 0.003 },
    guilt:        { root: 196.00, intervals: [1, 16/15, 6/5, 4/3, 64/45, 8/5, 9/5], mode: 'locrian', tempo: 7500, filterBase: 380, padType: 'sine', padVol: 0.018, noiseVol: 0.007 },
    love:         { root: 246.94, intervals: [1, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8], mode: 'ionian', tempo: 5500, filterBase: 1000, padType: 'sine', padVol: 0.022, noiseVol: 0.004 },
    confusion:    { root: 207.65, intervals: [1, 16/15, 6/5, 7/5, 3/2, 8/5, 7/4], mode: 'altered', tempo: 5000, filterBase: 550, padType: 'sine', padVol: 0.014, noiseVol: 0.009 },
    awe:          { root: 130.81, intervals: [1, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8], mode: 'ionian', tempo: 9000, filterBase: 500, padType: 'sine', padVol: 0.026, noiseVol: 0.006 },
    envy:         { root: 185.00, intervals: [1, 9/8, 6/5, 4/3, 3/2, 8/5, 9/5], mode: 'aeolian', tempo: 5000, filterBase: 480, padType: 'sawtooth', padVol: 0.013, noiseVol: 0.006 },
    disgust:      { root: 138.59, intervals: [1, 16/15, 6/5, 4/3, 64/45, 8/5, 9/5], mode: 'locrian', tempo: 6000, filterBase: 280, padType: 'sawtooth', padVol: 0.012, noiseVol: 0.010 },
  };
  const DEFAULT_SCALE = EMOTION_SCALES.serenity;

  function createReverb() {
    // Algorithmic reverb via convolver with generated impulse
    const sr = ctx.sampleRate, len = sr * 2.8, buf = ctx.createBuffer(2, len, sr);
    for (let ch = 0; ch < 2; ch++) {
      const d = buf.getChannelData(ch);
      for (let i = 0; i < len; i++) {
        d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2.2);
        // Early reflections
        if (i < sr * 0.08) d[i] *= 1.4;
      }
    }
    return buf;
  }

  function createNoiseBuffer() {
    const sr = ctx.sampleRate, len = sr * 2, buf = ctx.createBuffer(1, len, sr);
    const d = buf.getChannelData(0);
    // Pink-ish noise (attenuated highs)
    let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
    for (let i = 0; i < len; i++) {
      const w = Math.random() * 2 - 1;
      b0 = 0.99886*b0 + w*0.0555179; b1 = 0.99332*b1 + w*0.0750759;
      b2 = 0.96900*b2 + w*0.1538520; b3 = 0.86650*b3 + w*0.3104856;
      b4 = 0.55000*b4 + w*0.5329522; b5 = -0.7616*b5 - w*0.0168980;
      d[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + w * 0.5362) * 0.11;
      b6 = w * 0.115926;
    }
    return buf;
  }

  function init() {
    if (ctx) return;
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // === Master chain: compressor → output ===
    mainComp = ctx.createDynamicsCompressor();
    mainComp.threshold.value = -18; mainComp.knee.value = 12;
    mainComp.ratio.value = 4; mainComp.attack.value = 0.01; mainComp.release.value = 0.15;
    master = ctx.createGain(); master.gain.value = 0;
    master.connect(mainComp); mainComp.connect(ctx.destination);

    // === Main filter ===
    mainFilt = ctx.createBiquadFilter();
    mainFilt.type = 'lowpass'; mainFilt.frequency.value = 600; mainFilt.Q.value = 0.8;
    mainFilt.connect(master);

    // === Reverb send/return ===
    verbSend = ctx.createGain(); verbSend.gain.value = 0.35;
    verbConv = ctx.createConvolver(); verbConv.buffer = createReverb();
    verbReturn = ctx.createGain(); verbReturn.gain.value = 0.5;
    const verbFilt = ctx.createBiquadFilter(); verbFilt.type = 'lowpass'; verbFilt.frequency.value = 3000;
    verbSend.connect(verbConv); verbConv.connect(verbFilt); verbFilt.connect(verbReturn); verbReturn.connect(master);

    // === Stereo delay ===
    delSend = ctx.createGain(); delSend.gain.value = 0.15;
    delNode = ctx.createDelay(); delNode.delayTime.value = 0.375;
    delFb = ctx.createGain(); delFb.gain.value = 0.3;
    delFilt = ctx.createBiquadFilter(); delFilt.type = 'lowpass'; delFilt.frequency.value = 1400;
    delSend.connect(delNode); delNode.connect(delFilt); delFilt.connect(delFb);
    delFb.connect(delNode); delFilt.connect(master);

    // === LFOs for movement ===
    lfo1 = ctx.createOscillator(); lfo1.type = 'sine'; lfo1.frequency.value = 0.08;
    lfo1Gain = ctx.createGain(); lfo1Gain.gain.value = 3;
    lfo1.connect(lfo1Gain); lfo1.start();

    lfo2 = ctx.createOscillator(); lfo2.type = 'sine'; lfo2.frequency.value = 0.035;
    lfo2Gain = ctx.createGain(); lfo2Gain.gain.value = 50;
    lfo2.connect(lfo2Gain); lfo2.start();

    // === Pad layer: 4 voices, each a pair of detuned oscillators ===
    padGain = ctx.createGain(); padGain.gain.value = 0;
    padGain.connect(mainFilt); padGain.connect(verbSend); padGain.connect(delSend);
    for (let i = 0; i < 4; i++) {
      const osc1 = ctx.createOscillator(); const osc2 = ctx.createOscillator();
      const g = ctx.createGain(); const panner = ctx.createStereoPanner();
      osc1.type = 'sine'; osc2.type = 'sine';
      osc1.frequency.value = 130 + i * 65; osc2.frequency.value = 130.4 + i * 65;
      g.gain.value = 0; panner.pan.value = (i - 1.5) / 2.5; // spread stereo
      osc1.connect(g); osc2.connect(g); g.connect(panner); panner.connect(padGain);
      lfo1Gain.connect(osc1.frequency); // Gentle pitch wobble
      osc1.start(); osc2.start();
      padVoices.push({ osc1, osc2, gain: g, panner, baseFreq: 130 + i * 65 });
    }

    // === Sub-bass drone ===
    subGain = ctx.createGain(); subGain.gain.value = 0;
    subFilt = ctx.createBiquadFilter(); subFilt.type = 'lowpass'; subFilt.frequency.value = 120; subFilt.Q.value = 1.5;
    subOsc = ctx.createOscillator(); subOsc.type = 'sine'; subOsc.frequency.value = 65.41;
    subOsc.connect(subFilt); subFilt.connect(subGain); subGain.connect(master);
    subOsc.start();

    // === Texture layer: looping pink noise ===
    noiseGain = ctx.createGain(); noiseGain.gain.value = 0;
    noiseFilt = ctx.createBiquadFilter(); noiseFilt.type = 'bandpass'; noiseFilt.frequency.value = 400; noiseFilt.Q.value = 0.5;
    noiseNode = ctx.createBufferSource(); noiseNode.buffer = createNoiseBuffer();
    noiseNode.loop = true;
    noiseNode.connect(noiseFilt); noiseFilt.connect(noiseGain); noiseGain.connect(mainFilt);
    noiseGain.connect(verbSend);
    lfo2Gain.connect(noiseFilt.frequency); // Slow filter sweep on noise
    noiseNode.start();

    // === Chime/melody bus ===
    chimeGain = ctx.createGain(); chimeGain.gain.value = 1;
    chimeGain.connect(mainFilt); chimeGain.connect(verbSend); chimeGain.connect(delSend);

    currentScale = buildScale(DEFAULT_SCALE);
    currentRoot = DEFAULT_SCALE.root;
  }

  function buildScale(scaleData) {
    // Build 3 octaves of notes from the scale intervals
    const notes = [];
    for (let oct = 0; oct < 3; oct++) {
      const mult = Math.pow(2, oct - 1); // octaves: 0.5x, 1x, 2x
      scaleData.intervals.forEach(interval => {
        notes.push(scaleData.root * interval * mult);
      });
    }
    return notes.sort((a, b) => a - b);
  }

  function blendScales(emotions) {
    const sorted = Object.entries(emotions).sort((a, b) => b[1] - a[1]);
    if (!sorted.length) return DEFAULT_SCALE;
    const total = sorted.reduce((s, [,v]) => s + v, 0);
    // Weighted blend of the top 3 emotion parameters
    const top = sorted.slice(0, 3);
    let root = 0, filterBase = 0, tempo = 0, padVol = 0, noiseVol = 0;
    let dominantType = 'sine';
    top.forEach(([emo, w], i) => {
      const sc = EMOTION_SCALES[emo] || DEFAULT_SCALE;
      const n = w / total;
      root += sc.root * n;
      filterBase += sc.filterBase * n;
      tempo += sc.tempo * n;
      padVol += sc.padVol * n;
      noiseVol += sc.noiseVol * n;
      if (i === 0) dominantType = sc.padType;
    });
    // Use the dominant emotion's intervals for the scale
    const domScale = EMOTION_SCALES[sorted[0][0]] || DEFAULT_SCALE;
    return { root, intervals: domScale.intervals, filterBase, tempo, padType: dominantType, padVol, noiseVol };
  }

  // Generative melody: plays one gentle chime note from the current scale
  function playChime() {
    if (!active || !ctx || currentScale.length === 0) return;
    const now = ctx.currentTime;
    // Pick a note from the mid-upper range (pentatonic feel: skip some)
    const midScale = currentScale.filter(f => f > 200 && f < 1200);
    if (!midScale.length) return;
    const freq = midScale[Math.floor(Math.random() * midScale.length)];
    const vel = 0.02 + Math.random() * 0.025; // Soft dynamics

    // Bell tone: fundamental + 5th partial + octave, each with different decay
    const partials = [
      { mult: 1, vol: vel, decay: 3.5 + Math.random() * 2 },
      { mult: 1.498, vol: vel * 0.3, decay: 2.2 + Math.random() },
      { mult: 2.003, vol: vel * 0.15, decay: 1.8 + Math.random() },
    ];
    partials.forEach(p => {
      const osc = ctx.createOscillator(); const g = ctx.createGain();
      osc.type = 'sine'; osc.frequency.value = freq * p.mult;
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(p.vol, now + 0.008);
      g.gain.exponentialRampToValueAtTime(0.0001, now + p.decay);
      osc.connect(g); g.connect(chimeGain);
      osc.start(now); osc.stop(now + p.decay + 0.1);
    });

    // Occasionally play a second note (interval) 300-600ms later
    if (Math.random() < 0.35) {
      const delay2 = 0.3 + Math.random() * 0.3;
      const f2 = midScale[Math.floor(Math.random() * midScale.length)];
      const osc2 = ctx.createOscillator(); const g2 = ctx.createGain();
      osc2.type = 'sine'; osc2.frequency.value = f2;
      g2.gain.setValueAtTime(0, now + delay2);
      g2.gain.linearRampToValueAtTime(vel * 0.7, now + delay2 + 0.008);
      g2.gain.exponentialRampToValueAtTime(0.0001, now + delay2 + 3);
      osc2.connect(g2); g2.connect(chimeGain);
      osc2.start(now + delay2); osc2.stop(now + delay2 + 3.5);
    }

    // Schedule next chime with some randomness
    const blend = blendScales(gardenMood);
    const interval = (blend.tempo || 5000) * (0.7 + Math.random() * 0.6);
    melodyTimer = setTimeout(playChime, interval);
  }

  function start() {
    if (!ctx) init();
    if (ctx.state === 'suspended') ctx.resume();
    active = true;
    const now = ctx.currentTime;
    master.gain.cancelScheduledValues(now);
    master.gain.setValueAtTime(master.gain.value, now);
    master.gain.linearRampToValueAtTime(0.18, now + 3);
    padGain.gain.linearRampToValueAtTime(0.014, now + 4);
    subGain.gain.linearRampToValueAtTime(0.025, now + 5);
    noiseGain.gain.linearRampToValueAtTime(0.005, now + 4);
    // Start generative melody after a gentle delay
    if (melodyTimer) clearTimeout(melodyTimer);
    melodyTimer = setTimeout(playChime, 2000 + Math.random() * 3000);
  }

  function stop() {
    active = false;
    if (!ctx) return;
    const now = ctx.currentTime;
    master.gain.cancelScheduledValues(now);
    master.gain.setValueAtTime(master.gain.value, now);
    master.gain.linearRampToValueAtTime(0, now + 2);
    padGain.gain.linearRampToValueAtTime(0, now + 2);
    subGain.gain.linearRampToValueAtTime(0, now + 2);
    noiseGain.gain.linearRampToValueAtTime(0, now + 2);
    if (melodyTimer) { clearTimeout(melodyTimer); melodyTimer = null; }
  }

  function updateAmbient(entries) {
    if (!active || !ctx) return;
    // Aggregate emotions across all organisms
    const agg = {};
    entries.forEach(e => {
      Object.entries(e.emotions).forEach(([k, v]) => { agg[k] = (agg[k] || 0) + v; });
    });
    gardenMood = agg;
    const total = Object.values(agg).reduce((s, v) => s + v, 0);
    const now = ctx.currentTime;
    const ramp = 6; // Slow, organic transitions

    if (total === 0) {
      // Empty garden: quiet, sparse, default serenity drone
      padVoices.forEach((v, i) => {
        const f = DEFAULT_SCALE.root * DEFAULT_SCALE.intervals[i % DEFAULT_SCALE.intervals.length] * 0.5;
        v.osc1.frequency.linearRampToValueAtTime(f, now + ramp);
        v.osc2.frequency.linearRampToValueAtTime(f * 1.003, now + ramp);
        v.osc1.type = 'sine'; v.osc2.type = 'sine';
        v.gain.gain.linearRampToValueAtTime(0.006, now + ramp);
      });
      subOsc.frequency.linearRampToValueAtTime(DEFAULT_SCALE.root * 0.5, now + ramp);
      subGain.gain.linearRampToValueAtTime(0.012, now + ramp);
      mainFilt.frequency.linearRampToValueAtTime(400, now + ramp);
      noiseGain.gain.linearRampToValueAtTime(0.003, now + ramp);
      currentScale = buildScale(DEFAULT_SCALE);
      currentRoot = DEFAULT_SCALE.root;
      return;
    }

    // Blend emotional scales
    const blend = blendScales(agg);
    currentScale = buildScale(blend);
    currentRoot = blend.root;

    // Population density affects volume and richness
    const density = Math.min(1, entries.length / 12);

    // === Update pad voicings ===
    // Voice the pad as a chord from the blended scale
    const chordTones = [
      blend.root * 0.5,                                    // Root (sub octave)
      blend.root * blend.intervals[2],                     // Third
      blend.root * blend.intervals[4],                     // Fifth
      blend.root * blend.intervals[6] || blend.root * 2,   // Seventh or octave
    ];
    padVoices.forEach((v, i) => {
      const freq = chordTones[i] || blend.root;
      v.osc1.frequency.linearRampToValueAtTime(freq, now + ramp);
      v.osc2.frequency.linearRampToValueAtTime(freq * (1 + 0.002 + Math.random() * 0.002), now + ramp); // slight detune
      v.osc1.type = blend.padType || 'sine';
      v.osc2.type = blend.padType || 'sine';
      v.gain.gain.linearRampToValueAtTime((blend.padVol || 0.018) * (0.7 + density * 0.3), now + ramp);
    });
    padGain.gain.linearRampToValueAtTime(0.012 + density * 0.008, now + ramp);

    // === Sub-bass follows root ===
    subOsc.frequency.linearRampToValueAtTime(blend.root * 0.5, now + ramp);
    subGain.gain.linearRampToValueAtTime(0.018 + density * 0.012, now + ramp);

    // === Main filter opens/closes based on emotional brightness ===
    mainFilt.frequency.linearRampToValueAtTime(blend.filterBase || 600, now + ramp);

    // === Noise texture ===
    noiseGain.gain.linearRampToValueAtTime((blend.noiseVol || 0.005) * (0.6 + density * 0.4), now + ramp);
    // Shift noise band based on mood
    noiseFilt.frequency.linearRampToValueAtTime((blend.filterBase || 400) * 0.6, now + ramp);

    // === Reverb/delay respond to mood ===
    // More reverb for spacious emotions (awe, serenity, love), less for tight ones (anger, fear)
    const spaciousEmotions = ['awe', 'serenity', 'love', 'nostalgia', 'sadness'];
    const tightEmotions = ['anger', 'fear', 'disgust', 'envy'];
    let spaceWeight = 0;
    Object.entries(agg).forEach(([emo, w]) => {
      const n = w / total;
      if (spaciousEmotions.includes(emo)) spaceWeight += n;
      else if (tightEmotions.includes(emo)) spaceWeight -= n * 0.5;
    });
    spaceWeight = Math.max(0.15, Math.min(0.7, 0.35 + spaceWeight * 0.4));
    verbSend.gain.linearRampToValueAtTime(spaceWeight, now + ramp);
    delFb.gain.linearRampToValueAtTime(0.2 + spaceWeight * 0.2, now + ramp);

    // === LFO speed responds to energy ===
    const energeticEmotions = ['joy', 'anger', 'surprise', 'anticipation'];
    let energy = 0;
    Object.entries(agg).forEach(([emo, w]) => {
      if (energeticEmotions.includes(emo)) energy += w / total;
    });
    lfo1.frequency.linearRampToValueAtTime(0.05 + energy * 0.12, now + ramp);
  }

  function playTone(emotions) {
    if (!active || !ctx) return;
    const sorted = Object.entries(emotions).sort((a, b) => b[1] - a[1]);
    const dom = sorted[0]?.[0];
    const sc = EMOTION_SCALES[dom] || DEFAULT_SCALE;
    const scale = buildScale(sc);
    const midNotes = scale.filter(f => f > 180 && f < 900);
    if (!midNotes.length) return;
    const now = ctx.currentTime;

    // Rich bell: fundamental + harmonics with stereo spread
    const freq = midNotes[Math.floor(Math.random() * midNotes.length)];
    [
      { mult: 1, vol: 0.06, decay: 3.2, pan: -0.2 },
      { mult: 2.01, vol: 0.022, decay: 2.0, pan: 0.2 },
      { mult: 3.98, vol: 0.008, decay: 1.2, pan: -0.4 },
    ].forEach(p => {
      const osc = ctx.createOscillator(); const g = ctx.createGain();
      const pan = ctx.createStereoPanner(); pan.pan.value = p.pan;
      osc.type = 'sine'; osc.frequency.value = freq * p.mult;
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(p.vol, now + 0.012);
      g.gain.exponentialRampToValueAtTime(0.0001, now + p.decay);
      osc.connect(g); g.connect(pan); pan.connect(chimeGain);
      osc.start(now); osc.stop(now + p.decay + 0.1);
    });

    // Second interval note
    if (sorted.length > 1) {
      const sc2 = EMOTION_SCALES[sorted[1][0]] || DEFAULT_SCALE;
      const f2 = sc2.root * sc2.intervals[Math.floor(Math.random() * sc2.intervals.length)];
      const osc2 = ctx.createOscillator(); const g2 = ctx.createGain();
      osc2.type = 'sine'; osc2.frequency.value = f2;
      g2.gain.setValueAtTime(0, now + 0.15);
      g2.gain.linearRampToValueAtTime(0.028, now + 0.16);
      g2.gain.exponentialRampToValueAtTime(0.0001, now + 2.5);
      osc2.connect(g2); g2.connect(chimeGain);
      osc2.start(now + 0.15); osc2.stop(now + 3);
    }
  }

  function playRelease(emotions) {
    if (!active || !ctx) return;
    const sorted = Object.entries(emotions).sort((a, b) => b[1] - a[1]);
    const dom = sorted[0]?.[0];
    const sc = EMOTION_SCALES[dom] || DEFAULT_SCALE;
    const now = ctx.currentTime;

    // Ascending arpeggio through the scale
    const arpNotes = sc.intervals.slice(0, 5).map(i => sc.root * i);
    arpNotes.forEach((freq, i) => {
      const osc = ctx.createOscillator(); const g = ctx.createGain();
      const pan = ctx.createStereoPanner();
      pan.pan.value = (i - 2) / 3; // Spread across stereo field
      osc.type = 'sine'; osc.frequency.value = freq;
      g.gain.setValueAtTime(0, now + i * 0.18);
      g.gain.linearRampToValueAtTime(0.045 - i * 0.006, now + i * 0.18 + 0.012);
      g.gain.exponentialRampToValueAtTime(0.0001, now + i * 0.18 + 3);
      osc.connect(g); g.connect(pan); pan.connect(chimeGain);
      osc.start(now + i * 0.18); osc.stop(now + i * 0.18 + 3.5);
    });

    // Shimmering octave bloom on top
    const shimFreq = sc.root * 4;
    const shim = ctx.createOscillator(); const sg = ctx.createGain();
    shim.type = 'sine'; shim.frequency.value = shimFreq;
    sg.gain.setValueAtTime(0, now + 0.6);
    sg.gain.linearRampToValueAtTime(0.015, now + 0.65);
    sg.gain.exponentialRampToValueAtTime(0.0001, now + 4);
    shim.connect(sg); sg.connect(chimeGain);
    shim.start(now + 0.6); shim.stop(now + 4.5);

    // Momentary pad swell to mark the release
    if (padGain) {
      const cur = padGain.gain.value;
      padGain.gain.setValueAtTime(cur, now);
      padGain.gain.linearRampToValueAtTime(cur * 1.6, now + 0.5);
      padGain.gain.linearRampToValueAtTime(cur, now + 3);
    }
  }

  return { init, start, stop, updateAmbient, playTone, playRelease, isActive: () => active };
}

function analyzeEmotions(text) {
  const lower = text.toLowerCase();
  const words = lower.split(/\s+/);
  const scores = {};
  Object.entries(EMOTIONS).forEach(([key, { keywords }]) => {
    let score = 0;
    keywords.forEach(kw => {
      if (kw.includes(" ")) {
        const m = lower.match(new RegExp(kw, "gi"));
        if (m) score += m.length * 2;
      } else {
        words.forEach(w => {
          const c = w.replace(/[^a-z]/g, "");
          if (c === kw || (c.length > 3 && (c.startsWith(kw) || kw.startsWith(c)))) score++;
        });
      }
    });
    if (score > 0) scores[key] = score;
  });
  const total = Object.values(scores).reduce((a, b) => a + b, 0);
  if (total === 0) return {};
  const n = {};
  Object.entries(scores).forEach(([k, v]) => { n[k] = v / total; });
  return n;
}

function getSize(len) { return Math.min(40, 14 + Math.sqrt(len) * 0.9); }

function getTopColors(emotions, count = 3) {
  const sorted = Object.entries(emotions).sort((a, b) => b[1] - a[1]).slice(0, count);
  return sorted.map(([key, weight]) => ({ color: EMOTIONS[key].color, weight, key }));
}

function blendColors(emotions) {
  const tops = getTopColors(emotions);
  if (!tops.length) return [70, 70, 90];
  const sum = tops.reduce((s, t) => s + t.weight, 0);
  let r = 0, g = 0, b = 0;
  tops.forEach(t => { r += t.color[0]*(t.weight/sum); g += t.color[1]*(t.weight/sum); b += t.color[2]*(t.weight/sum); });
  return [Math.round(r), Math.round(g), Math.round(b)];
}

/* Canvas */
const EcosystemCanvas = ({ creatures, width, height, onCreatureClick, selectedId }) => {
  const canvasRef = useRef(null);
  const animRef = useRef(null);
  const stateRef = useRef([]);
  const particlesRef = useRef([]);
  const mouseRef = useRef({ x: -999, y: -999 });
  const hitRef = useRef(null);
  const trailsRef = useRef([]);
  const sporesRef = useRef([]);
  const ripplesRef = useRef([]);
  const motesRef = useRef([]);
  const emotionFxRef = useRef([]);
  const terrainRef = useRef(null);
  const selectedRef = useRef(selectedId);
  const sizeRef = useRef({ width, height });
  const onClickRef = useRef(onCreatureClick);

  selectedRef.current = selectedId;
  sizeRef.current = { width, height };
  onClickRef.current = onCreatureClick;

  useEffect(() => {
    const existing = stateRef.current;
    stateRef.current = creatures.map(c => {
      const prev = existing.find(e => e.id === c.id);
      if (prev) return { ...prev, size: c.size, colors: c.colors, blended: c.blended, emotionCount: c.emotionCount, isLive: c.isLive };
      const seeds = [];
      for (let i = 0; i < 6; i++) seeds.push(Math.random() * Math.PI * 2);
      return {
        ...c,
        x: width * 0.15 + Math.random() * width * 0.7,
        y: height * 0.15 + Math.random() * height * 0.7,
        vx: (Math.random() - 0.5) * 0.25, vy: (Math.random() - 0.5) * 0.25,
        phase: Math.random() * Math.PI * 2, scale: 0.01, seeds,
        lobes: 3 + Math.floor(Math.random() * 3),
        breathSync: 0, nearbyTint: [0,0,0,0], lastTrailDrop: 0,
      };
    });
  }, [creatures, width, height]);

  useEffect(() => {
    const isMob = width < 600;
    const count = isMob ? Math.min(50, 20 + creatures.length * 3) : Math.min(120, 45 + creatures.length * 5);
    while (particlesRef.current.length < count) {
      particlesRef.current.push({ x: Math.random()*width, y: Math.random()*height, vx: (Math.random()-0.5)*0.04, vy: (Math.random()-0.5)*0.04, size: 0.4+Math.random()*2.2, alpha: 0.02+Math.random()*0.1 });
    }
    if (particlesRef.current.length > count) particlesRef.current.length = count;
  }, [creatures.length, width, height]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    let t = 0, running = true;

    const GRID_COLS = 24, GRID_ROWS = 16;
    if (!terrainRef.current || terrainRef.current.length !== GRID_COLS * GRID_ROWS) {
      terrainRef.current = Array.from({ length: GRID_COLS * GRID_ROWS }, () => ({ r:0, g:0, b:0, strength:0, bloom:0 }));
    }
    const terrain = terrainRef.current;

    const doResize = () => {
      const dpr = window.devicePixelRatio || 1;
      const { width: w, height: h } = sizeRef.current;
      if (w <= 0 || h <= 0) return;
      canvas.width = Math.round(w * dpr); canvas.height = Math.round(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };
    doResize();

    const draw = () => {
      if (!running) return;
      t += 0.003;
      const { width: W, height: H } = sizeRef.current;
      if (W <= 0 || H <= 0) { animRef.current = requestAnimationFrame(draw); return; }
      const selId = selectedRef.current;
      const dpr = window.devicePixelRatio || 1;
      if (canvas.width !== Math.round(W * dpr) || canvas.height !== Math.round(H * dpr)) doResize();
      ctx.clearRect(0, 0, W, H);
      const allCrs = stateRef.current;
      const isMobile = W < 600;

      // MAJOR 3: Living soil
      const cellW = W / GRID_COLS, cellH = H / GRID_ROWS;
      allCrs.forEach(c => {
        if (c.scale < 0.3) return;
        const [cr, cg, cb] = c.blended;
        const col = Math.floor(c.x / cellW), row = Math.floor(c.y / cellH);
        const depositRate = 0.0004 * c.size / 20;
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            const r2 = row+dr, c2 = col+dc;
            if (r2<0||r2>=GRID_ROWS||c2<0||c2>=GRID_COLS) continue;
            const idx = r2*GRID_COLS+c2, cell = terrain[idx];
            const falloff = (dr===0&&dc===0)?1:0.35, dep = depositRate*falloff;
            if (cell.strength < 0.001) { cell.r=cr; cell.g=cg; cell.b=cb; cell.strength+=dep; }
            else { const total=cell.strength+dep; cell.r=(cell.r*cell.strength+cr*dep)/total; cell.g=(cell.g*cell.strength+cg*dep)/total; cell.b=(cell.b*cell.strength+cb*dep)/total; cell.strength=total; }
            if (cell.strength > 1) cell.strength = 1;
          }
        }
      });
      for (let i = 0; i < terrain.length; i++) {
        if (terrain[i].strength > 0) terrain[i].strength = Math.max(0, terrain[i].strength - 0.00008);
        if (terrain[i].bloom > 0.0001 || terrain[i].strength > 0) { terrain[i].bloom += (terrain[i].strength - terrain[i].bloom) * 0.02; if (terrain[i].bloom < 0.0001) terrain[i].bloom = 0; }
      }
      const bloomThreshold = isMobile ? 0.015 : 0.005;
      for (let row = 0; row < GRID_ROWS; row++) {
        for (let col = 0; col < GRID_COLS; col++) {
          if (isMobile && (row+col)%2!==0) continue;
          const cell = terrain[row*GRID_COLS+col];
          if (cell.bloom < bloomThreshold) continue;
          const cx = (col+0.5)*cellW, cy = (row+0.5)*cellH;
          const radius = Math.max(cellW,cellH)*(0.9+Math.sin(t*0.1+col*0.5+row*0.3)*0.15);
          const alpha = cell.bloom * 0.06;
          const grad = ctx.createRadialGradient(cx,cy,0,cx,cy,radius);
          grad.addColorStop(0, `rgba(${Math.round(cell.r)},${Math.round(cell.g)},${Math.round(cell.b)},${alpha})`);
          grad.addColorStop(0.5, `rgba(${Math.round(cell.r)},${Math.round(cell.g)},${Math.round(cell.b)},${alpha*0.4})`);
          grad.addColorStop(1, `rgba(${Math.round(cell.r)},${Math.round(cell.g)},${Math.round(cell.b)},0)`);
          ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(cx,cy,radius,0,Math.PI*2); ctx.fill();
        }
      }

      // Background
      // Ambient breathing - the whole space gently pulses with the garden's mood
      if (allCrs.length > 0) {
        let avgR=0,avgG=0,avgB=0;
        allCrs.forEach(c=>{avgR+=c.blended[0];avgG+=c.blended[1];avgB+=c.blended[2];});
        avgR/=allCrs.length;avgG/=allCrs.length;avgB/=allCrs.length;
        const breathAlpha = 0.012 + Math.sin(t * 0.15) * 0.006;
        const bgGrad = ctx.createRadialGradient(W*0.5,H*0.5,0,W*0.5,H*0.5,Math.max(W,H)*0.7);
        bgGrad.addColorStop(0, `rgba(${Math.round(avgR*0.15)},${Math.round(avgG*0.15)},${Math.round(avgB*0.15)},${breathAlpha})`);
        bgGrad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = bgGrad; ctx.fillRect(0,0,W,H);
      }

      // Aurora ribbons - flowing bands of light that drift across the space
      const auroraCount = isMobile ? 2 : 4;
      for (let a = 0; a < auroraCount; a++) {
        const aY = H * (0.15 + a * 0.22) + Math.sin(t * 0.04 + a * 1.9) * H * 0.12;
        const aAmplitude = H * (0.06 + Math.sin(t * 0.03 + a * 2.4) * 0.025);
        let aR = 35, aG = 40, aB = 55;
        if (allCrs.length > 0) {
          const src = allCrs[a % allCrs.length].blended;
          aR = src[0] * 0.12 + 18; aG = src[1] * 0.12 + 18; aB = src[2] * 0.15 + 25;
        }
        const aAlpha = 0.015 + Math.sin(t * 0.06 + a * 1.3) * 0.008;
        ctx.save(); ctx.globalAlpha = aAlpha;
        ctx.beginPath();
        ctx.moveTo(-10, aY);
        const segments = isMobile ? 12 : 24;
        for (let s = 0; s <= segments; s++) {
          const sx = (s / segments) * (W + 20) - 10;
          const sy = aY + Math.sin(t * 0.08 + s * 0.4 + a * 2.1) * aAmplitude
                        + Math.sin(t * 0.12 + s * 0.7 + a * 0.8) * aAmplitude * 0.4;
          ctx.lineTo(sx, sy);
        }
        const ribbonH = H * (0.06 + Math.sin(t * 0.05 + a) * 0.02);
        for (let s = segments; s >= 0; s--) {
          const sx = (s / segments) * (W + 20) - 10;
          const sy = aY + ribbonH + Math.sin(t * 0.08 + s * 0.4 + a * 2.1 + 0.5) * aAmplitude * 0.7
                        + Math.sin(t * 0.12 + s * 0.7 + a * 0.8 + 0.3) * aAmplitude * 0.3;
          ctx.lineTo(sx, sy);
        }
        ctx.closePath();
        const aGrad = ctx.createLinearGradient(0, aY - aAmplitude, 0, aY + ribbonH + aAmplitude);
        aGrad.addColorStop(0, `rgba(${Math.round(aR)},${Math.round(aG)},${Math.round(aB)},0)`);
        aGrad.addColorStop(0.3, `rgba(${Math.round(aR)},${Math.round(aG)},${Math.round(aB)},0.7)`);
        aGrad.addColorStop(0.7, `rgba(${Math.round(aR*0.8)},${Math.round(aG*0.8)},${Math.round(aB*1.1)},0.5)`);
        aGrad.addColorStop(1, `rgba(${Math.round(aR)},${Math.round(aG)},${Math.round(aB)},0)`);
        ctx.fillStyle = aGrad; ctx.fill();
        ctx.restore();
      }

      // Nebulae (enhanced - more organic shapes)
      const nebulaCount = isMobile ? 2 : 4;
      for (let n = 0; n < nebulaCount; n++) {
        const nx = W*(0.2+n*(0.6/nebulaCount))+Math.sin(t*0.12+n*1.7)*W*0.12;
        const ny = H*(0.3+(n%2)*0.35)+Math.cos(t*0.09+n*2.1)*H*0.1;
        const nr = Math.max(W,H)*(0.2+Math.sin(t*0.07+n)*0.05);
        let cr2=30,cg2=30,cb2=45;
        if (allCrs.length>0) { const bl=allCrs[n%allCrs.length].blended; cr2=bl[0]*0.15+18; cg2=bl[1]*0.15+18; cb2=bl[2]*0.18+28; }
        const nebGrad = ctx.createRadialGradient(nx,ny,0,nx,ny,nr);
        nebGrad.addColorStop(0, `rgba(${Math.round(cr2)},${Math.round(cg2)},${Math.round(cb2)},${0.045+Math.sin(t*0.15+n*0.8)*0.02})`);
        nebGrad.addColorStop(0.4, `rgba(${Math.round(cr2*0.8)},${Math.round(cg2*0.8)},${Math.round(cb2*0.9)},0.02)`);
        nebGrad.addColorStop(0.7, `rgba(${Math.round(cr2*0.6)},${Math.round(cg2*0.6)},${Math.round(cb2*0.7)},0.008)`);
        nebGrad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = nebGrad; ctx.beginPath(); ctx.arc(nx,ny,nr,0,Math.PI*2); ctx.fill();
      }

      // Stars (enhanced with gentle twinkle color)
      const starCount = isMobile ? 18 : 40;
      for (let s = 0; s < starCount; s++) {
        const sx2=(Math.sin(s*137.5)*0.5+0.5)*W, sy2=(Math.cos(s*97.3)*0.5+0.5)*H;
        const tw=Math.sin(t*(0.3+s*0.07)+s*2.7)*0.5+0.5;
        const starSize = 0.4 + tw * 1.0;
        let sr=185,sg=190,sb=215;
        // Stars near organisms pick up faint color
        if (!isMobile && allCrs.length>0) {
          let minD=Infinity, nearC=null;
          allCrs.forEach(c=>{const d=(c.x-sx2)*(c.x-sx2)+(c.y-sy2)*(c.y-sy2);if(d<minD){minD=d;nearC=c;}});
          if(minD<90000&&nearC){const blend=1-Math.sqrt(minD)/300;sr=185+(nearC.blended[0]-185)*blend*0.25;sg=190+(nearC.blended[1]-190)*blend*0.25;sb=215+(nearC.blended[2]-215)*blend*0.25;}
        }
        ctx.beginPath(); ctx.arc(sx2,sy2,starSize,0,Math.PI*2);
        ctx.fillStyle=`rgba(${Math.round(sr)},${Math.round(sg)},${Math.round(sb)},${0.03+tw*0.08})`; ctx.fill();
        // Cross-flare on brightest stars
        if (tw > 0.7 && !isMobile) {
          const flareAlpha = (tw - 0.7) * 0.12;
          ctx.beginPath(); ctx.moveTo(sx2 - 4 - tw*3, sy2); ctx.lineTo(sx2 + 4 + tw*3, sy2);
          ctx.strokeStyle = `rgba(${Math.round(sr)},${Math.round(sg)},${Math.round(sb)},${flareAlpha})`; ctx.lineWidth = 0.5; ctx.stroke();
          ctx.beginPath(); ctx.moveTo(sx2, sy2 - 3 - tw*2); ctx.lineTo(sx2, sy2 + 3 + tw*2);
          ctx.stroke();
        }
      }

      // Luminous motes - larger wandering lights that drift through the space
      const moteTarget = allCrs.length > 0 ? (isMobile ? 4 : 8) : (isMobile ? 2 : 4);
      while (motesRef.current.length < moteTarget) {
        motesRef.current.push({
          x: Math.random() * W, y: Math.random() * H,
          vx: (Math.random()-0.5)*0.15, vy: (Math.random()-0.5)*0.15,
          size: 2 + Math.random() * 3, phase: Math.random() * Math.PI * 2,
          r: 140+Math.random()*60, g: 150+Math.random()*60, b: 170+Math.random()*60,
          pulseSpeed: 0.3 + Math.random() * 0.4, driftAngle: Math.random() * Math.PI * 2
        });
      }
      if (motesRef.current.length > moteTarget + 2) motesRef.current.length = moteTarget;
      motesRef.current.forEach(m => {
        // Drift with gentle curved paths
        m.driftAngle += (Math.random()-0.5)*0.02;
        m.vx += Math.cos(m.driftAngle)*0.003 + Math.sin(t*0.2+m.phase)*0.002;
        m.vy += Math.sin(m.driftAngle)*0.003 + Math.cos(t*0.15+m.phase)*0.002;
        // Gently attracted to nearest organism
        if (allCrs.length > 0) {
          let minD=Infinity,nearC=null;
          allCrs.forEach(c=>{const d=Math.sqrt((c.x-m.x)*(c.x-m.x)+(c.y-m.y)*(c.y-m.y));if(d<minD){minD=d;nearC=c;}});
          if (nearC && minD > 40 && minD < 300) {
            const pull = 0.0003 * (1 - minD/300);
            m.vx += (nearC.x - m.x) / minD * pull;
            m.vy += (nearC.y - m.y) / minD * pull;
            // Pick up organism color
            m.r += (nearC.blended[0] - m.r) * 0.005;
            m.g += (nearC.blended[1] - m.g) * 0.005;
            m.b += (nearC.blended[2] - m.b) * 0.005;
          }
          if (nearC && minD < 40) {
            m.vx += (m.x - nearC.x) / minD * 0.003;
            m.vy += (m.y - nearC.y) / minD * 0.003;
          }
        }
        m.vx *= 0.992; m.vy *= 0.992;
        const sp = Math.sqrt(m.vx*m.vx+m.vy*m.vy); if(sp>0.3){m.vx*=0.3/sp;m.vy*=0.3/sp;}
        m.x += m.vx; m.y += m.vy;
        if(m.x<-20)m.x=W+20; if(m.x>W+20)m.x=-20; if(m.y<-20)m.y=H+20; if(m.y>H+20)m.y=-20;
        const pulse = Math.sin(t * m.pulseSpeed + m.phase) * 0.5 + 0.5;
        const mSize = m.size * (0.6 + pulse * 0.4);
        // Outer glow
        const mGlow = ctx.createRadialGradient(m.x,m.y,0,m.x,m.y,mSize*6);
        mGlow.addColorStop(0, `rgba(${Math.round(m.r)},${Math.round(m.g)},${Math.round(m.b)},${0.03+pulse*0.025})`);
        mGlow.addColorStop(0.4, `rgba(${Math.round(m.r)},${Math.round(m.g)},${Math.round(m.b)},${0.01+pulse*0.008})`);
        mGlow.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = mGlow; ctx.beginPath(); ctx.arc(m.x,m.y,mSize*6,0,Math.PI*2); ctx.fill();
        // Core
        ctx.beginPath(); ctx.arc(m.x,m.y,mSize,0,Math.PI*2);
        ctx.fillStyle = `rgba(${Math.round(Math.min(255,m.r+40))},${Math.round(Math.min(255,m.g+40))},${Math.round(Math.min(255,m.b+40))},${0.06+pulse*0.06})`;
        ctx.fill();
      });

      // Organism ripples - periodic waves that emanate outward
      allCrs.forEach(c => {
        if (c.scale < 0.5) return;
        // Emit ripple every ~3 seconds per organism
        if (Math.sin(t * 0.35 + c.phase) > 0.98 && Math.sin((t-0.003) * 0.35 + c.phase) <= 0.98) {
          const [rr,rg,rb] = c.blended;
          ripplesRef.current.push({ x:c.x, y:c.y, r:rr, g:rg, b:rb, age:0, maxAge: isMobile?120:180, maxRadius: c.size * (6+Math.random()*3) });
        }
      });
      ripplesRef.current = ripplesRef.current.filter(rp => rp.age < rp.maxAge);
      ripplesRef.current.forEach(rp => {
        rp.age++;
        const life = rp.age / rp.maxAge;
        const radius = rp.maxRadius * life;
        const alpha = (1 - life) * (1 - life) * 0.045;
        const ringWidth = 1.5 * (1 - life) + 0.3;
        ctx.beginPath(); ctx.arc(rp.x, rp.y, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(${rp.r},${rp.g},${rp.b},${alpha})`;
        ctx.lineWidth = ringWidth; ctx.stroke();
        // Faint fill inside the ripple
        if (life < 0.3) {
          const fillAlpha = (1 - life/0.3) * 0.008;
          const rpGrad = ctx.createRadialGradient(rp.x,rp.y,0,rp.x,rp.y,radius);
          rpGrad.addColorStop(0, `rgba(${rp.r},${rp.g},${rp.b},${fillAlpha})`);
          rpGrad.addColorStop(1, `rgba(${rp.r},${rp.g},${rp.b},0)`);
          ctx.fillStyle = rpGrad; ctx.beginPath(); ctx.arc(rp.x,rp.y,radius,0,Math.PI*2); ctx.fill();
        }
      });
      if (ripplesRef.current.length > (isMobile?15:40)) ripplesRef.current.splice(0, ripplesRef.current.length-(isMobile?15:40));

      // Particles
      particlesRef.current.forEach((p, pi) => {
        p.x+=p.vx+Math.sin(t*0.5+p.y*0.002)*0.008; p.y+=p.vy+Math.cos(t*0.4+p.x*0.002)*0.008;
        if(p.x<0)p.x=W; if(p.x>W)p.x=0; if(p.y<0)p.y=H; if(p.y>H)p.y=0;
        const pPulse=p.size*(1+Math.sin(t*0.7+pi*0.4)*0.3);
        let pr2=160,pg2=170,pb2=195;
        if(allCrs.length>0&&!isMobile){ let minD=Infinity,nearest=allCrs[0]; for(let ci=0;ci<allCrs.length;ci++){const dx=allCrs[ci].x-p.x,dy=allCrs[ci].y-p.y,d2=dx*dx+dy*dy;if(d2<minD){minD=d2;nearest=allCrs[ci];}} if(minD<40000){const blend=1-Math.sqrt(minD)/200;pr2=160+(nearest.blended[0]-160)*blend*0.3;pg2=170+(nearest.blended[1]-170)*blend*0.3;pb2=195+(nearest.blended[2]-195)*blend*0.3;} }
        ctx.beginPath(); ctx.arc(p.x,p.y,pPulse,0,Math.PI*2);
        ctx.fillStyle=`rgba(${Math.round(pr2)},${Math.round(pg2)},${Math.round(pb2)},${p.alpha*(0.3+Math.sin(t+p.x*0.008)*0.3)})`; ctx.fill();
      });

      // INTERACTION SYSTEM

      // MAJOR 1: Memory trails
      const trailInterval = isMobile ? 0.35 : 0.15;
      allCrs.forEach(c => {
        if (t-(c.lastTrailDrop||0)>trailInterval && c.scale>0.5) {
          c.lastTrailDrop=t; const [tr2,tg2,tb2]=c.blended;
          trailsRef.current.push({x:c.x,y:c.y,r:tr2,g:tg2,b:tb2,age:0,maxAge:isMobile?250+Math.random()*100:400+Math.random()*200,size:c.size*c.scale*0.3});
        }
      });
      trailsRef.current = trailsRef.current.filter(tr => tr.age < tr.maxAge);
      trailsRef.current.forEach(tr => {
        tr.age++; const life=1-tr.age/tr.maxAge, alpha=life*life*0.025, sz=tr.size*(0.5+life*0.5);
        ctx.beginPath(); ctx.arc(tr.x,tr.y,sz,0,Math.PI*2); ctx.fillStyle=`rgba(${tr.r},${tr.g},${tr.b},${alpha})`; ctx.fill();
      });
      if (!isMobile && trailsRef.current.length > 2) {
        for (let i=0; i<trailsRef.current.length; i+=8) { const a=trailsRef.current[i]; if(a.age>a.maxAge*0.5)continue;
          for (let j=i+1; j<trailsRef.current.length; j+=8) { const b2=trailsRef.current[j]; if(b2.age>b2.maxAge*0.5)continue; if(a.r===b2.r&&a.g===b2.g&&a.b===b2.b)continue;
            const dx=a.x-b2.x,dy=a.y-b2.y; if(dx*dx+dy*dy<900){ const mx2=(a.x+b2.x)/2,my2=(a.y+b2.y)/2,lifeA=1-a.age/a.maxAge,lifeB=1-b2.age/b2.maxAge;
              ctx.beginPath();ctx.arc(mx2,my2,4,0,Math.PI*2);ctx.fillStyle=`rgba(${(a.r+b2.r)>>1},${(a.g+b2.g)>>1},${(a.b+b2.b)>>1},${lifeA*lifeB*0.04})`;ctx.fill(); }
          }
        }
      }
      if (trailsRef.current.length > (isMobile?100:600)) trailsRef.current.splice(0, trailsRef.current.length-(isMobile?100:600));

      // Proximity
      const proximityPairs = [];
      for (let i=0; i<allCrs.length; i++) {
        allCrs[i].nearbyTint=[0,0,0,0]; allCrs[i].breathSync=(allCrs[i].breathSync||0)*0.995; allCrs[i]._nearestAngle=null; allCrs[i]._nearestDist=Infinity;
        for (let j=i+1; j<allCrs.length; j++) {
          const dx=allCrs[i].x-allCrs[j].x, dy=allCrs[i].y-allCrs[j].y, dist=Math.sqrt(dx*dx+dy*dy);
          if (dist<300) {
            const aDom = allCrs[i].colors?.[0]?.key, bDom = allCrs[j].colors?.[0]?.key;
            const affinity = getAffinity(aDom, bDom);
            proximityPairs.push({i,j,dist,dx,dy,affinity});
            if(dist<allCrs[i]._nearestDist){allCrs[i]._nearestDist=dist;allCrs[i]._nearestAngle=Math.atan2(allCrs[j].y-allCrs[i].y,allCrs[j].x-allCrs[i].x);}
            if(dist<allCrs[j]._nearestDist){allCrs[j]._nearestDist=dist;allCrs[j]._nearestAngle=Math.atan2(allCrs[i].y-allCrs[j].y,allCrs[i].x-allCrs[j].x);}
          }
        }
      }

      proximityPairs.forEach(({i,j,dist,dx,dy,affinity}) => {
        const a=allCrs[i], b2=allCrs[j], closeness=1-dist/300;
        const [r1,g1,b1]=a.blended, [r2,g2,b2c]=b2.blended;
        const mx2=(a.x+b2.x)/2, my2=(a.y+b2.y)/2;
        const isKindred = affinity > 0.3;
        const isOpposite = affinity < -0.3;
        const absAffinity = Math.abs(affinity);

        // SUBTLE 1: Breath sync (kindred sync faster, opposites desync)
        const breathBlend = closeness * (isKindred ? 0.006 : isOpposite ? -0.002 : 0.003);
        a.breathSync+=(b2.phase-a.phase)*breathBlend; b2.breathSync+=(a.phase-b2.phase)*breathBlend;
        // SUBTLE 2: Color bleed (kindred blend more, opposites don't)
        const bleedStrength = closeness * closeness * (isKindred ? 0.22 : isOpposite ? 0.03 : 0.15);
        a.nearbyTint[0]+=r2*bleedStrength;a.nearbyTint[1]+=g2*bleedStrength;a.nearbyTint[2]+=b2c*bleedStrength;a.nearbyTint[3]+=bleedStrength;
        b2.nearbyTint[0]+=r1*bleedStrength;b2.nearbyTint[1]+=g1*bleedStrength;b2.nearbyTint[2]+=b1*bleedStrength;b2.nearbyTint[3]+=bleedStrength;

        if (dist < 220) {
          // ═══ KINDRED INTERACTIONS ═══
          if (isKindred) {
            // Warm, flowing tether
            const alpha=(1-dist/220)*0.12*absAffinity;
            const tmx=mx2+Math.sin(t*0.6+i+j)*25, tmy=my2+Math.cos(t*0.6+i-j)*25;
            ctx.beginPath();ctx.moveTo(a.x,a.y);ctx.quadraticCurveTo(tmx,tmy,b2.x,b2.y);
            const grad=ctx.createLinearGradient(a.x,a.y,b2.x,b2.y);
            grad.addColorStop(0,`rgba(${r1},${g1},${b1},${alpha})`);grad.addColorStop(0.5,`rgba(${(r1+r2)>>1},${(g1+g2)>>1},${(b1+b2c)>>1},${alpha*0.8})`);grad.addColorStop(1,`rgba(${r2},${g2},${b2c},${alpha})`);
            ctx.strokeStyle=grad;ctx.lineWidth=1.5+(1-dist/220)*2;ctx.stroke();
            // Flowing shared particles along tether
            if (!isMobile) {
              const tCount = 5;
              for(let d=0;d<tCount;d++){
                const frac=((t*0.3+d/tCount)%1);
                const tx=a.x+(b2.x-a.x)*frac+Math.sin(t*0.8+d*1.5)*8;
                const ty=a.y+(b2.y-a.y)*frac+Math.cos(t*0.8+d*1.5)*8;
                const pSize = 1.5 + Math.sin(frac*Math.PI)*1.5;
                ctx.beginPath();ctx.arc(tx,ty,pSize,0,Math.PI*2);
                ctx.fillStyle=`rgba(${(r1+r2)>>1},${(g1+g2)>>1},${(b1+b2c)>>1},${alpha*1.8*(0.5+Math.sin(frac*Math.PI)*0.5)})`;ctx.fill();
              }
            }
            // Shared aura pool - bigger and warmer for kindred
            if (dist<160) {
              const poolAlpha=(1-dist/160)*0.06*absAffinity,poolR=(a.size+b2.size)*0.9;
              const poolGrad=ctx.createRadialGradient(mx2,my2,0,mx2,my2,poolR);
              poolGrad.addColorStop(0,`rgba(${(r1+r2)>>1},${(g1+g2)>>1},${(b1+b2c)>>1},${poolAlpha})`);
              poolGrad.addColorStop(0.5,`rgba(${(r1+r2)>>1},${(g1+g2)>>1},${(b1+b2c)>>1},${poolAlpha*0.4})`);
              poolGrad.addColorStop(1,`rgba(${(r1+r2)>>1},${(g1+g2)>>1},${(b1+b2c)>>1},0)`);
              ctx.fillStyle=poolGrad;ctx.beginPath();ctx.arc(mx2,my2,poolR,0,Math.PI*2);ctx.fill();
            }
            // Spores - more frequent between kindred
            if (Math.random()<0.04*closeness) {
              const fromA=Math.random()>0.5,src=fromA?a:b2,dst=fromA?b2:a,[sr,sg,sb]=src.blended;
              sporesRef.current.push({x:src.x+(Math.random()-0.5)*src.size,y:src.y+(Math.random()-0.5)*src.size,vx:(dst.x-src.x)/dist*0.5+(Math.random()-0.5)*0.08,vy:(dst.y-src.y)/dist*0.5+(Math.random()-0.5)*0.08,r:sr,g:sg,b:sb,age:0,maxAge:100+Math.random()*80});
            }

          // ═══ OPPOSITE INTERACTIONS ═══
          } else if (isOpposite) {
            // Crackling tension line - jagged, unstable
            const tensionAlpha=(1-dist/220)*0.1*absAffinity;
            ctx.beginPath();ctx.moveTo(a.x,a.y);
            const segs = isMobile ? 6 : 12;
            for(let s=1;s<=segs;s++){
              const frac=s/segs;
              const lx=a.x+(b2.x-a.x)*frac;
              const ly=a.y+(b2.y-a.y)*frac;
              const jitterAmt = (1-Math.abs(frac-0.5)*2) * dist * 0.12 * (0.5+Math.sin(t*4+s*2.3)*0.5);
              const perpX = -dy/dist, perpY = dx/dist;
              const jx = lx + perpX * (Math.sin(t*3+s*1.7+i)*jitterAmt);
              const jy = ly + perpY * (Math.sin(t*3.5+s*2.1+j)*jitterAmt);
              ctx.lineTo(jx,jy);
            }
            ctx.strokeStyle=`rgba(255,255,255,${tensionAlpha*0.6})`;ctx.lineWidth=0.6;ctx.stroke();
            // Secondary colored tension line
            ctx.beginPath();ctx.moveTo(a.x,a.y);
            for(let s=1;s<=segs;s++){
              const frac=s/segs;
              const lx=a.x+(b2.x-a.x)*frac+Math.sin(t*5+s*3)*dist*0.06*(1-Math.abs(frac-0.5)*2);
              const ly=a.y+(b2.y-a.y)*frac+Math.cos(t*5+s*3)*dist*0.06*(1-Math.abs(frac-0.5)*2);
              ctx.lineTo(lx,ly);
            }
            ctx.strokeStyle=`rgba(${(r1+r2)>>1},${(g1+g2)>>1},${(b1+b2c)>>1},${tensionAlpha*0.4})`;ctx.lineWidth=1;ctx.stroke();

            // Collision sparks at midpoint
            if (dist < 150) {
              const sparkIntensity = (1-dist/150)*absAffinity;
              const sparkCount = isMobile ? 3 : 6;
              for(let s=0;s<sparkCount;s++){
                const sAge = (t*1.5+s*0.8+i*0.3+j*0.7)%1.2;
                if (sAge > 0.8) continue;
                const sLife = sAge / 0.8;
                const sAngle = (s/sparkCount)*Math.PI*2 + t*2 + i;
                const sDist2 = sLife * 30 * sparkIntensity;
                const sx = mx2 + Math.cos(sAngle)*sDist2;
                const sy = my2 + Math.sin(sAngle)*sDist2;
                const sSize = (1-sLife)*2*sparkIntensity;
                // Spark is white-hot in center
                ctx.beginPath();ctx.arc(sx,sy,sSize,0,Math.PI*2);
                ctx.fillStyle=`rgba(255,240,220,${(1-sLife)*0.15*sparkIntensity})`;ctx.fill();
              }
              // Turbulent energy pool
              const clashAlpha = sparkIntensity * 0.04;
              const clashR = (a.size+b2.size)*0.5;
              const clashGrad = ctx.createRadialGradient(mx2,my2,0,mx2,my2,clashR);
              clashGrad.addColorStop(0, `rgba(255,240,230,${clashAlpha})`);
              clashGrad.addColorStop(0.4, `rgba(${(r1+r2)>>1},${(g1+g2)>>1},${(b1+b2c)>>1},${clashAlpha*0.5})`);
              clashGrad.addColorStop(1, `rgba(${(r1+r2)>>1},${(g1+g2)>>1},${(b1+b2c)>>1},0)`);
              ctx.fillStyle=clashGrad;ctx.beginPath();ctx.arc(mx2,my2,clashR,0,Math.PI*2);ctx.fill();
              // Disruption rings
              const ringPhase = (t*0.8+i*0.4+j*0.6)%1.5;
              if (ringPhase < 1) {
                const ringLife = ringPhase;
                const ringR2 = 5 + ringLife*clashR*2;
                ctx.beginPath();ctx.arc(mx2,my2,ringR2,0,Math.PI*2);
                ctx.strokeStyle=`rgba(255,255,255,${(1-ringLife)*0.05*sparkIntensity})`;ctx.lineWidth=0.8*(1-ringLife);ctx.stroke();
              }
            }
            // Repelled spores - eject outward from collision
            if (dist < 130 && Math.random()<0.03*closeness) {
              const ejectAngle = Math.atan2(dy,dx) + (Math.random()-0.5)*1.5;
              const c1 = Math.random()>0.5 ? a.blended : b2.blended;
              sporesRef.current.push({x:mx2,y:my2,vx:Math.cos(ejectAngle)*0.8,vy:Math.sin(ejectAngle)*0.8,r:c1[0],g:c1[1],b:c1[2],age:0,maxAge:60+Math.random()*40});
            }

          // ═══ NEUTRAL INTERACTIONS ═══
          } else {
            // Standard tether
            const alpha=(1-dist/220)*0.06;
            const tmx=mx2+Math.sin(t*1.2+i+j)*20, tmy=my2+Math.cos(t*1.2+i-j)*20;
            ctx.beginPath();ctx.moveTo(a.x,a.y);ctx.quadraticCurveTo(tmx,tmy,b2.x,b2.y);
            const grad=ctx.createLinearGradient(a.x,a.y,b2.x,b2.y);
            grad.addColorStop(0,`rgba(${r1},${g1},${b1},${alpha})`);grad.addColorStop(0.5,`rgba(${(r1+r2)>>1},${(g1+g2)>>1},${(b1+b2c)>>1},${alpha*0.6})`);grad.addColorStop(1,`rgba(${r2},${g2},${b2c},${alpha})`);
            ctx.strokeStyle=grad;ctx.lineWidth=1+(1-dist/220)*1.5;ctx.stroke();
            if (!isMobile) { for(let d=0;d<3;d++){const frac=(d+1)/4+Math.sin(t*0.8+d+i)*0.05,tx=a.x+(b2.x-a.x)*frac+Math.sin(t+d)*4,ty=a.y+(b2.y-a.y)*frac+Math.cos(t+d)*4;ctx.beginPath();ctx.arc(tx,ty,1.2,0,Math.PI*2);ctx.fillStyle=`rgba(${(r1+r2)>>1},${(g1+g2)>>1},${(b1+b2c)>>1},${alpha*1.5})`;ctx.fill();} }
            if (Math.random()<0.02*closeness) {
              const fromA=Math.random()>0.5,src=fromA?a:b2,dst=fromA?b2:a,[sr,sg,sb]=src.blended;
              sporesRef.current.push({x:src.x+(Math.random()-0.5)*src.size,y:src.y+(Math.random()-0.5)*src.size,vx:(dst.x-src.x)/dist*0.4+(Math.random()-0.5)*0.1,vy:(dst.y-src.y)/dist*0.4+(Math.random()-0.5)*0.1,r:sr,g:sg,b:sb,age:0,maxAge:80+Math.random()*60});
            }
            if (dist<160) {
              const poolAlpha=(1-dist/160)*0.04,poolR=(a.size+b2.size)*0.6;
              const poolGrad=ctx.createRadialGradient(mx2,my2,0,mx2,my2,poolR);
              poolGrad.addColorStop(0,`rgba(${(r1+r2)>>1},${(g1+g2)>>1},${(b1+b2c)>>1},${poolAlpha})`);poolGrad.addColorStop(1,`rgba(${(r1+r2)>>1},${(g1+g2)>>1},${(b1+b2c)>>1},0)`);
              ctx.fillStyle=poolGrad;ctx.beginPath();ctx.arc(mx2,my2,poolR,0,Math.PI*2);ctx.fill();
            }
          }
        }

        // MAJOR 2: Resonance bloom (same or kindred emotions)
        if (dist<150&&a.colors&&b2.colors&&a.colors.length>0&&b2.colors.length>0) {
          const aDom=a.colors[0].key, bDom=b2.colors[0].key;
          if (aDom===bDom || isKindred) {
            const resonance=(1-dist/150) * (aDom===bDom ? 1 : 0.5);
            const [rr,rg,rb]=EMOTIONS[aDom]?.color||[150,150,150];
            const ringPhase=t*1.5+i*0.5+j*0.3;
            for(let ring=0;ring<3;ring++){const ringFrac=((ringPhase+ring*0.33)%1),ringR=10+ringFrac*(a.size+b2.size)*1.5,ringAlpha=resonance*(1-ringFrac)*0.06;ctx.beginPath();ctx.arc(mx2,my2,ringR,0,Math.PI*2);ctx.strokeStyle=`rgba(${rr},${rg},${rb},${ringAlpha})`;ctx.lineWidth=1.5*(1-ringFrac);ctx.stroke();}
            const cenGlow=ctx.createRadialGradient(mx2,my2,0,mx2,my2,(a.size+b2.size)*0.5);
            cenGlow.addColorStop(0,`rgba(${Math.min(255,rr+50)},${Math.min(255,rg+50)},${Math.min(255,rb+50)},${resonance*0.06})`);cenGlow.addColorStop(1,`rgba(${rr},${rg},${rb},0)`);
            ctx.fillStyle=cenGlow;ctx.beginPath();ctx.arc(mx2,my2,(a.size+b2.size)*0.5,0,Math.PI*2);ctx.fill();
            if(!isMobile){for(let sp=0;sp<4;sp++){const sa=ringPhase*Math.PI*2+sp*Math.PI*0.5,sr2=15+Math.sin(t*2+sp)*8,spx=mx2+Math.cos(sa)*sr2,spy=my2+Math.sin(sa)*sr2;ctx.beginPath();ctx.arc(spx,spy,1+Math.sin(t*3+sp)*0.5,0,Math.PI*2);ctx.fillStyle=`rgba(${Math.min(255,rr+80)},${Math.min(255,rg+80)},${Math.min(255,rb+80)},${resonance*(0.08+Math.sin(t*2+sp)*0.04)})`;ctx.fill();}}
            const resCol=Math.floor(mx2/cellW),resRow=Math.floor(my2/cellH),resDep=resonance*0.003;
            for(let dr=-2;dr<=2;dr++){for(let dc=-2;dc<=2;dc++){const rr2=resRow+dr,cc2=resCol+dc;if(rr2<0||rr2>=GRID_ROWS||cc2<0||cc2>=GRID_COLS)continue;const falloff2=1/(1+Math.abs(dr)+Math.abs(dc)),idx2=rr2*GRID_COLS+cc2,tc=terrain[idx2],d2=resDep*falloff2;if(tc.strength<0.001){tc.r=rr;tc.g=rg;tc.b=rb;tc.strength+=d2;}else{const tot=tc.strength+d2;tc.r=(tc.r*tc.strength+rr*d2)/tot;tc.g=(tc.g*tc.strength+rg*d2)/tot;tc.b=(tc.b*tc.strength+rb*d2)/tot;tc.strength=Math.min(1,tot);}}}
          }
        }
      });

      // Spores draw
      sporesRef.current=sporesRef.current.filter(s=>s.age<s.maxAge);
      sporesRef.current.forEach(s=>{s.x+=s.vx;s.y+=s.vy;s.vx*=0.98;s.vy*=0.98;s.vx+=Math.sin(t*2+s.x*0.01)*0.01;s.vy+=Math.cos(t*2+s.y*0.01)*0.01;s.age++;const life=1-s.age/s.maxAge;ctx.beginPath();ctx.arc(s.x,s.y,1+life*1.5,0,Math.PI*2);ctx.fillStyle=`rgba(${s.r},${s.g},${s.b},${life*0.15})`;ctx.fill();});
      if(sporesRef.current.length>(isMobile?40:120))sporesRef.current.splice(0,sporesRef.current.length-(isMobile?40:120));

      // Organisms
      allCrs.forEach((c) => {
        const domEmo = (c.colors && c.colors.length > 0) ? c.colors[0].key : null;
        const domWeight = (c.colors && c.colors.length > 0) ? c.colors[0].weight : 0;
        let ax2=Math.sin(t*0.25+c.phase)*0.001+Math.sin(t*0.13+c.phase*2.3)*0.0006;
        let ay2=Math.cos(t*0.2+c.phase+1)*0.001+Math.cos(t*0.17+c.phase*1.7)*0.0006;

        // Emotion-specific movement
        if (!c.isLive && domEmo === 'fear') {
          // Trembling micro-vibrations
          ax2 += (Math.random()-0.5)*0.006*domWeight;
          ay2 += (Math.random()-0.5)*0.006*domWeight;
        } else if (!c.isLive && domEmo === 'anger') {
          // Sharper, more agitated movement
          ax2 += Math.sin(t*3.5+c.phase)*0.003*domWeight;
          ay2 += Math.cos(t*4.1+c.phase)*0.003*domWeight;
        } else if (!c.isLive && domEmo === 'serenity') {
          // Slower, more deliberate drift
          ax2 *= 0.5; ay2 *= 0.5;
        } else if (!c.isLive && domEmo === 'sadness') {
          // Gentle downward drift
          ay2 += 0.0008*domWeight;
        } else if (!c.isLive && (domEmo === 'joy' || domEmo === 'anticipation')) {
          // Slight buoyant upward tendency
          ay2 -= 0.0005*domWeight;
        }

        const mdx=c.x-mouseRef.current.x,mdy=c.y-mouseRef.current.y,md=Math.sqrt(mdx*mdx+mdy*mdy);
        if(md<80&&md>0&&hitRef.current!==c.id){ax2+=(mdx/md)*0.008;ay2+=(mdy/md)*0.008;}
        c.vx+=ax2;c.vy+=ay2;c.vx*=0.997;c.vy*=0.997;
        const sp=Math.sqrt(c.vx*c.vx+c.vy*c.vy);if(sp>0.45){c.vx*=0.45/sp;c.vy*=0.45/sp;}
        c.x+=c.vx;c.y+=c.vy;
        const pad=60;if(c.x<pad)c.vx+=0.015;if(c.x>W-pad)c.vx-=0.015;if(c.y<pad)c.vy+=0.015;if(c.y>H-pad)c.vy-=0.015;
        c.scale+=(1-c.scale)*0.02;

        const [r,g,b]=c.blended, sz=c.size*c.scale, isHovered=hitRef.current===c.id, isSelected=selId===c.id;
        const syncPhase=c.phase+(c.breathSync||0);
        // Emotion-specific breathing rates
        let breathSpeed = 0.8, breathDepth = 0.06;
        if (!c.isLive && domEmo === 'serenity') { breathSpeed = 0.35; breathDepth = 0.08; }
        else if (!c.isLive && domEmo === 'anger') { breathSpeed = 1.8; breathDepth = 0.09; }
        else if (!c.isLive && domEmo === 'fear') { breathSpeed = 1.4; breathDepth = 0.04; }
        else if (!c.isLive && domEmo === 'joy') { breathSpeed = 1.0; breathDepth = 0.07; }
        else if (!c.isLive && domEmo === 'love') { breathSpeed = 0.5; breathDepth = 0.08; }
        else if (!c.isLive && domEmo === 'sadness') { breathSpeed = 0.4; breathDepth = 0.05; }
        else if (!c.isLive && domEmo === 'awe') { breathSpeed = 0.3; breathDepth = 0.1; }
        const breathe=Math.sin(t*breathSpeed+syncPhase)*breathDepth;
        const S=sz*(1+breathe)*(isHovered?1.12:1);

        // Color bleed tint
        const tint=c.nearbyTint||[0,0,0,0], tintStr=tint[3]>0?Math.min(tint[3],1):0;
        const tr=tintStr>0?Math.round(r*(1-tintStr*0.3)+(tint[0]/tint[3])*tintStr*0.3):r;
        const tg=tintStr>0?Math.round(g*(1-tintStr*0.3)+(tint[1]/tint[3])*tintStr*0.3):g;
        const tb=tintStr>0?Math.round(b*(1-tintStr*0.3)+(tint[2]/tint[3])*tintStr*0.3):b;

        // Glow
        const glowR=S*(isHovered?5:isSelected?4.5:3.5);
        const glow=ctx.createRadialGradient(c.x,c.y,0,c.x,c.y,glowR);
        glow.addColorStop(0,`rgba(${tr},${tg},${tb},${isHovered?0.1:0.035})`);glow.addColorStop(0.4,`rgba(${tr},${tg},${tb},${isHovered?0.04:0.012})`);glow.addColorStop(1,`rgba(${r},${g},${b},0)`);
        ctx.fillStyle=glow;ctx.beginPath();ctx.arc(c.x,c.y,glowR,0,Math.PI*2);ctx.fill();

        if(isSelected){ctx.beginPath();ctx.arc(c.x,c.y,S*2.2,0,Math.PI*2);ctx.strokeStyle=`rgba(${r},${g},${b},${0.08+Math.sin(t*2)*0.04})`;ctx.lineWidth=0.8;ctx.setLineDash([3,5]);ctx.stroke();ctx.setLineDash([]);}

        // Body
        ctx.beginPath();const pts=isMobile?60:120;
        for(let i=0;i<=pts;i++){const a=(i/pts)*Math.PI*2;let rad=S;for(let s2=0;s2<c.seeds.length;s2++)rad+=Math.sin(a*(c.lobes+s2*0.7)+c.seeds[s2]+t*(0.3+s2*0.1))*S*(0.08+s2*0.03);rad+=Math.sin(a*2+t*0.5+c.phase)*S*0.05;const px=c.x+Math.cos(a)*rad,py=c.y+Math.sin(a)*rad;i===0?ctx.moveTo(px,py):ctx.lineTo(px,py);}
        ctx.closePath();
        const colors=c.colors||[];
        const bodyGrad=ctx.createRadialGradient(c.x+Math.sin(t*0.4+c.phase)*S*0.15,c.y+Math.cos(t*0.3+c.phase)*S*0.15,0,c.x,c.y,S*1.3);
        if(colors.length>=3){bodyGrad.addColorStop(0,`rgba(${Math.min(255,colors[0].color[0]+50)},${Math.min(255,colors[0].color[1]+50)},${Math.min(255,colors[0].color[2]+50)},0.45)`);bodyGrad.addColorStop(0.35,`rgba(${colors[1].color[0]},${colors[1].color[1]},${colors[1].color[2]},0.25)`);bodyGrad.addColorStop(0.7,`rgba(${colors[2].color[0]},${colors[2].color[1]},${colors[2].color[2]},0.15)`);bodyGrad.addColorStop(1,`rgba(${r},${g},${b},0.03)`);}
        else if(colors.length===2){bodyGrad.addColorStop(0,`rgba(${Math.min(255,colors[0].color[0]+50)},${Math.min(255,colors[0].color[1]+50)},${Math.min(255,colors[0].color[2]+50)},0.45)`);bodyGrad.addColorStop(0.5,`rgba(${colors[1].color[0]},${colors[1].color[1]},${colors[1].color[2]},0.2)`);bodyGrad.addColorStop(1,`rgba(${r},${g},${b},0.03)`);}
        else{bodyGrad.addColorStop(0,`rgba(${Math.min(255,r+60)},${Math.min(255,g+60)},${Math.min(255,b+60)},0.4)`);bodyGrad.addColorStop(1,`rgba(${r},${g},${b},0.04)`);}
        ctx.fillStyle=bodyGrad;ctx.fill();

        // Membrane
        ctx.beginPath();const pts2=isMobile?40:80;
        for(let i=0;i<=pts2;i++){const a=(i/pts2)*Math.PI*2;let rad=S*0.6;for(let s2=0;s2<Math.min(3,c.seeds.length);s2++)rad+=Math.sin(a*(c.lobes+1+s2)+c.seeds[s2]+t*(0.4+s2*0.15))*S*0.06;const px=c.x+Math.cos(a)*rad,py=c.y+Math.sin(a)*rad;i===0?ctx.moveTo(px,py):ctx.lineTo(px,py);}
        ctx.closePath();ctx.fillStyle=`rgba(${Math.min(255,r+40)},${Math.min(255,g+40)},${Math.min(255,b+40)},${0.06+breathe*0.03})`;ctx.fill();

        // Nucleus
        const nx2=c.x+Math.sin(t*0.3+c.phase)*S*0.1,ny2=c.y+Math.cos(t*0.25+c.phase)*S*0.1;
        ctx.beginPath();ctx.arc(nx2,ny2,S*0.18,0,Math.PI*2);const nucGrad=ctx.createRadialGradient(nx2,ny2,0,nx2,ny2,S*0.18);
        nucGrad.addColorStop(0,`rgba(${Math.min(255,r+80)},${Math.min(255,g+80)},${Math.min(255,b+80)},0.2)`);nucGrad.addColorStop(1,`rgba(${r},${g},${b},0.04)`);ctx.fillStyle=nucGrad;ctx.fill();

        // SUBTLE 5: Strands with reaching
        const safeColors=colors.length>0?colors:[{color:[r,g,b]}], strandCount=4+Math.min(c.emotionCount||0,5);
        const nearAngle=c._nearestAngle,nearDist=c._nearestDist||Infinity,reachStrength=nearAngle!=null&&nearDist<200?(1-nearDist/200)*0.4:0;
        for(let i=0;i<strandCount;i++){
          const baseAngle=(i/strandCount)*Math.PI*2+c.seeds[i%c.seeds.length];
          let sway=Math.sin(t*0.6+i*0.9+c.phase)*0.3;
          if(nearAngle!=null&&reachStrength>0){let angleDiff=nearAngle-baseAngle;while(angleDiff>Math.PI)angleDiff-=Math.PI*2;while(angleDiff<-Math.PI)angleDiff+=Math.PI*2;const facing=Math.max(0,1-Math.abs(angleDiff)/(Math.PI*0.6));sway+=angleDiff*facing*reachStrength*0.5;}
          let len=S*(0.5+Math.sin(t*0.4+i*1.1+c.phase)*0.25);
          if(nearAngle!=null&&reachStrength>0){let angleDiff=nearAngle-baseAngle;while(angleDiff>Math.PI)angleDiff-=Math.PI*2;while(angleDiff<-Math.PI)angleDiff+=Math.PI*2;const facing=Math.max(0,1-Math.abs(angleDiff)/(Math.PI*0.5));len+=S*facing*reachStrength*0.3;}
          const startR=S*0.7,sx2=c.x+Math.cos(baseAngle)*startR,sy2=c.y+Math.sin(baseAngle)*startR;
          const tipX=c.x+Math.cos(baseAngle+sway)*(startR+len),tipY=c.y+Math.sin(baseAngle+sway)*(startR+len);
          ctx.beginPath();ctx.moveTo(sx2,sy2);ctx.quadraticCurveTo((sx2+tipX)/2+Math.sin(t+i)*S*0.15,(sy2+tipY)/2+Math.cos(t+i)*S*0.15,tipX,tipY);
          const sc2=safeColors[i%safeColors.length].color;ctx.strokeStyle=`rgba(${sc2[0]},${sc2[1]},${sc2[2]},${0.06+Math.sin(t*0.8+i)*0.03})`;ctx.lineWidth=1.2;ctx.stroke();
        }

        // EMOTION-SPECIFIC EFFECTS (only for submitted entries)
        if (!c.isLive) {
        const intensity = isHovered ? 1.5 : (isSelected ? 1.2 : 1.0);
        const fxAlpha = domWeight * intensity;

        if (domEmo === 'joy') {
          // Golden sparkles float upward like tiny celebrations
          const sparkCount = isMobile ? 4 : 7;
          for (let sp = 0; sp < sparkCount; sp++) {
            const age = (t * 0.8 + sp * 1.3 + c.phase) % 2.0;
            if (age > 1.5) continue;
            const life = age / 1.5;
            const angle = (sp / sparkCount) * Math.PI * 2 + Math.sin(t * 0.3 + sp) * 0.5;
            const dist = S * (0.8 + life * 2.5);
            const spx = c.x + Math.cos(angle) * dist * 0.6;
            const spy = c.y - life * S * 2.5 + Math.sin(angle) * dist * 0.3;
            const sparkSize = (1 - life) * 2.5 * fxAlpha;
            const sparkAlpha = (1 - life) * 0.15 * fxAlpha;
            ctx.beginPath(); ctx.arc(spx, spy, sparkSize, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255,230,100,${sparkAlpha})`; ctx.fill();
            // Tiny cross flare
            if (!isMobile && sparkSize > 1) {
              ctx.beginPath(); ctx.moveTo(spx - sparkSize * 2, spy); ctx.lineTo(spx + sparkSize * 2, spy);
              ctx.strokeStyle = `rgba(255,240,150,${sparkAlpha * 0.5})`; ctx.lineWidth = 0.4; ctx.stroke();
            }
          }
          // Warm radiance halo
          const joyHalo = ctx.createRadialGradient(c.x, c.y, S, c.x, c.y, S * 3);
          joyHalo.addColorStop(0, `rgba(255,215,80,${0.03 * fxAlpha})`);
          joyHalo.addColorStop(0.5, `rgba(255,200,60,${0.012 * fxAlpha})`);
          joyHalo.addColorStop(1, "rgba(255,215,80,0)");
          ctx.fillStyle = joyHalo; ctx.beginPath(); ctx.arc(c.x, c.y, S * 3, 0, Math.PI * 2); ctx.fill();

        } else if (domEmo === 'sadness') {
          // Teardrops fall slowly downward
          const dropCount = isMobile ? 3 : 5;
          for (let d = 0; d < dropCount; d++) {
            const age = (t * 0.3 + d * 0.8 + c.phase) % 2.5;
            const life = age / 2.5;
            const dx = Math.sin(d * 2.1 + c.phase) * S * 0.7;
            const dy = life * S * 4;
            const dropAlpha = (1 - life) * (life > 0.1 ? 1 : life / 0.1) * 0.1 * fxAlpha;
            const dropSize = (1 - life * 0.5) * 1.8;
            ctx.beginPath(); ctx.arc(c.x + dx, c.y + dy, dropSize, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(80,100,190,${dropAlpha})`; ctx.fill();
            // Trail behind drop
            if (!isMobile) {
              ctx.beginPath(); ctx.moveTo(c.x + dx, c.y + dy - dropSize);
              ctx.lineTo(c.x + dx - dropSize * 0.3, c.y + dy - dropSize * 3);
              ctx.lineTo(c.x + dx + dropSize * 0.3, c.y + dy - dropSize * 3);
              ctx.closePath(); ctx.fillStyle = `rgba(80,100,190,${dropAlpha * 0.5})`; ctx.fill();
            }
          }
          // Muted, inward-pulling aura
          const sadGlow = ctx.createRadialGradient(c.x, c.y, S * 0.5, c.x, c.y, S * 2.2);
          sadGlow.addColorStop(0, `rgba(60,70,140,${0.04 * fxAlpha})`);
          sadGlow.addColorStop(1, "rgba(40,50,120,0)");
          ctx.fillStyle = sadGlow; ctx.beginPath(); ctx.arc(c.x, c.y, S * 2.2, 0, Math.PI * 2); ctx.fill();

        } else if (domEmo === 'anger') {
          // Electric crackling arcs around edges
          const arcCount = isMobile ? 4 : 7;
          for (let a = 0; a < arcCount; a++) {
            const baseAngle = (a / arcCount) * Math.PI * 2 + t * 1.5;
            const jitter = Math.sin(t * 8 + a * 3.7 + c.phase) * 0.4;
            const startDist = S * 0.9;
            const endDist = S * (1.3 + Math.random() * 0.8 * fxAlpha);
            const sx = c.x + Math.cos(baseAngle) * startDist;
            const sy = c.y + Math.sin(baseAngle) * startDist;
            const ex = c.x + Math.cos(baseAngle + jitter) * endDist;
            const ey = c.y + Math.sin(baseAngle + jitter) * endDist;
            const mx = (sx + ex) / 2 + (Math.random() - 0.5) * S * 0.5;
            const my = (sy + ey) / 2 + (Math.random() - 0.5) * S * 0.5;
            ctx.beginPath(); ctx.moveTo(sx, sy); ctx.quadraticCurveTo(mx, my, ex, ey);
            ctx.strokeStyle = `rgba(255,${80 + Math.random() * 60},40,${0.12 * fxAlpha * (0.5 + Math.random() * 0.5)})`;
            ctx.lineWidth = 0.6 + Math.random() * 0.8; ctx.stroke();
          }
          // Hot pulsing core
          const angerPulse = Math.sin(t * 3 + c.phase) * 0.5 + 0.5;
          const angerGlow = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, S * 1.5);
          angerGlow.addColorStop(0, `rgba(255,60,30,${0.04 * fxAlpha * angerPulse})`);
          angerGlow.addColorStop(1, "rgba(210,40,20,0)");
          ctx.fillStyle = angerGlow; ctx.beginPath(); ctx.arc(c.x, c.y, S * 1.5, 0, Math.PI * 2); ctx.fill();

        } else if (domEmo === 'fear') {
          // Flickering shadow wisps that contract close
          const wispCount = isMobile ? 3 : 6;
          for (let w = 0; w < wispCount; w++) {
            const wAngle = (w / wispCount) * Math.PI * 2 + t * 0.4 + c.phase;
            const flicker = Math.sin(t * 4 + w * 2.3) * 0.5 + 0.5;
            const wDist = S * (0.7 + flicker * 0.5);
            const wLen = S * (0.3 + flicker * 0.4);
            const wx = c.x + Math.cos(wAngle) * wDist;
            const wy = c.y + Math.sin(wAngle) * wDist;
            const wex = c.x + Math.cos(wAngle + 0.3) * (wDist + wLen);
            const wey = c.y + Math.sin(wAngle + 0.3) * (wDist + wLen);
            ctx.beginPath(); ctx.moveTo(wx, wy);
            ctx.quadraticCurveTo(wx + Math.sin(t * 3 + w) * 5, wy + Math.cos(t * 3 + w) * 5, wex, wey);
            ctx.strokeStyle = `rgba(80,40,100,${0.06 * fxAlpha * flicker})`; ctx.lineWidth = 1 + flicker; ctx.stroke();
          }
          // Contracting/expanding shadow ring
          const fearPulse = Math.sin(t * 1.5 + c.phase) * 0.15;
          ctx.beginPath(); ctx.arc(c.x, c.y, S * (1.6 + fearPulse), 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(100,50,130,${0.04 * fxAlpha})`; ctx.lineWidth = 0.8; ctx.setLineDash([2, 4 + Math.sin(t * 2) * 2]); ctx.stroke(); ctx.setLineDash([]);

        } else if (domEmo === 'surprise') {
          // Periodic starburst flashes
          const burstPhase = (t * 0.5 + c.phase) % 3.0;
          if (burstPhase < 0.6) {
            const burstLife = burstPhase / 0.6;
            const rays = isMobile ? 6 : 10;
            for (let ray = 0; ray < rays; ray++) {
              const rAngle = (ray / rays) * Math.PI * 2 + c.phase;
              const rLen = S * (0.5 + burstLife * 2.5) * fxAlpha;
              const rAlpha = (1 - burstLife) * 0.12 * fxAlpha;
              ctx.beginPath();
              ctx.moveTo(c.x + Math.cos(rAngle) * S * 0.5, c.y + Math.sin(rAngle) * S * 0.5);
              ctx.lineTo(c.x + Math.cos(rAngle) * rLen, c.y + Math.sin(rAngle) * rLen);
              ctx.strokeStyle = `rgba(255,180,70,${rAlpha})`; ctx.lineWidth = 1.5 * (1 - burstLife); ctx.stroke();
            }
            // Central flash
            const flashGlow = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, S * burstLife * 2);
            flashGlow.addColorStop(0, `rgba(255,200,100,${(1 - burstLife) * 0.08 * fxAlpha})`);
            flashGlow.addColorStop(1, "rgba(255,180,70,0)");
            ctx.fillStyle = flashGlow; ctx.beginPath(); ctx.arc(c.x, c.y, S * burstLife * 2, 0, Math.PI * 2); ctx.fill();
          }

        } else if (domEmo === 'trust') {
          // Steady warm concentric shields
          for (let ring = 0; ring < 3; ring++) {
            const rRadius = S * (1.5 + ring * 0.7);
            const rAlpha = 0.03 * fxAlpha * (1 - ring * 0.25);
            const rPulse = Math.sin(t * 0.3 + ring * 0.8 + c.phase) * 0.02;
            ctx.beginPath(); ctx.arc(c.x, c.y, rRadius * (1 + rPulse), 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(80,185,150,${rAlpha})`; ctx.lineWidth = 1.5 - ring * 0.3; ctx.stroke();
          }
          // Grounding warmth beneath
          const trustGrad = ctx.createRadialGradient(c.x, c.y + S * 0.3, 0, c.x, c.y + S * 0.3, S * 2.5);
          trustGrad.addColorStop(0, `rgba(80,185,150,${0.025 * fxAlpha})`);
          trustGrad.addColorStop(1, "rgba(80,185,150,0)");
          ctx.fillStyle = trustGrad; ctx.beginPath(); ctx.arc(c.x, c.y + S * 0.3, S * 2.5, 0, Math.PI * 2); ctx.fill();

        } else if (domEmo === 'anticipation') {
          // Rising light bubbles
          const bubCount = isMobile ? 3 : 6;
          for (let b = 0; b < bubCount; b++) {
            const age = (t * 0.5 + b * 0.9 + c.phase) % 2.8;
            const life = age / 2.8;
            const bx = c.x + Math.sin(b * 2.3 + c.phase + t * 0.2) * S * 0.8;
            const by = c.y - life * S * 3.5;
            const bSize = (1 - life) * 2.5 * (0.5 + Math.sin(life * Math.PI) * 0.5);
            const bAlpha = Math.sin(life * Math.PI) * 0.1 * fxAlpha;
            ctx.beginPath(); ctx.arc(bx, by, bSize, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(240,170,190,${bAlpha})`; ctx.lineWidth = 0.6; ctx.stroke();
            // Bright spot on bubble
            ctx.beginPath(); ctx.arc(bx - bSize * 0.3, by - bSize * 0.3, bSize * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255,200,220,${bAlpha * 0.8})`; ctx.fill();
          }

        } else if (domEmo === 'serenity') {
          // Slow concentric water ripple rings
          for (let ring = 0; ring < 4; ring++) {
            const rPhase = (t * 0.15 + ring * 0.6 + c.phase) % 2.5;
            const rLife = rPhase / 2.5;
            const rRadius = S * (1 + rLife * 3);
            const rAlpha = (1 - rLife) * (1 - rLife) * 0.04 * fxAlpha;
            ctx.beginPath(); ctx.arc(c.x, c.y, rRadius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(150,200,215,${rAlpha})`; ctx.lineWidth = 1.2 * (1 - rLife); ctx.stroke();
          }
          // Soft ambient field
          const calmField = ctx.createRadialGradient(c.x, c.y, S, c.x, c.y, S * 4);
          calmField.addColorStop(0, `rgba(150,200,215,${0.015 * fxAlpha})`);
          calmField.addColorStop(0.5, `rgba(140,190,210,${0.006 * fxAlpha})`);
          calmField.addColorStop(1, "rgba(150,200,215,0)");
          ctx.fillStyle = calmField; ctx.beginPath(); ctx.arc(c.x, c.y, S * 4, 0, Math.PI * 2); ctx.fill();

        } else if (domEmo === 'nostalgia') {
          // Ghostly after-images trailing behind
          const ghostCount = isMobile ? 2 : 4;
          for (let g = 1; g <= ghostCount; g++) {
            const gx = c.x - c.vx * g * 25;
            const gy = c.y - c.vy * g * 25;
            const gAlpha = (1 - g / (ghostCount + 1)) * 0.035 * fxAlpha;
            const gSize = S * (1 - g * 0.08);
            const gGrad = ctx.createRadialGradient(gx, gy, 0, gx, gy, gSize);
            gGrad.addColorStop(0, `rgba(195,160,120,${gAlpha})`);
            gGrad.addColorStop(1, "rgba(195,160,120,0)");
            ctx.fillStyle = gGrad; ctx.beginPath(); ctx.arc(gx, gy, gSize, 0, Math.PI * 2); ctx.fill();
          }
          // Warm sepia haze
          const nostGlow = ctx.createRadialGradient(c.x, c.y, S * 0.5, c.x, c.y, S * 2.5);
          nostGlow.addColorStop(0, `rgba(195,160,120,${0.025 * fxAlpha})`);
          nostGlow.addColorStop(1, "rgba(175,140,100,0)");
          ctx.fillStyle = nostGlow; ctx.beginPath(); ctx.arc(c.x, c.y, S * 2.5, 0, Math.PI * 2); ctx.fill();

        } else if (domEmo === 'pride') {
          // Crown-like radiant spikes above
          const spikeCount = isMobile ? 4 : 6;
          for (let sp = 0; sp < spikeCount; sp++) {
            const spAngle = -Math.PI * 0.5 + (sp / (spikeCount - 1) - 0.5) * Math.PI * 0.6;
            const spLen = S * (1.5 + Math.sin(t * 0.6 + sp * 1.2 + c.phase) * 0.4) * fxAlpha;
            const spx = c.x + Math.cos(spAngle) * S * 0.6;
            const spy = c.y + Math.sin(spAngle) * S * 0.6;
            const tex = c.x + Math.cos(spAngle) * (S * 0.6 + spLen);
            const tey = c.y + Math.sin(spAngle) * (S * 0.6 + spLen);
            ctx.beginPath(); ctx.moveTo(spx, spy); ctx.lineTo(tex, tey);
            ctx.strokeStyle = `rgba(220,185,60,${0.08 * fxAlpha * (0.6 + Math.sin(t * 0.8 + sp) * 0.4)})`;
            ctx.lineWidth = 1.2; ctx.stroke();
            // Tip glow
            ctx.beginPath(); ctx.arc(tex, tey, 1.5, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255,220,80,${0.12 * fxAlpha})`; ctx.fill();
          }
          // Upward light beam
          const beamGrad = ctx.createLinearGradient(c.x, c.y - S, c.x, c.y - S * 4);
          beamGrad.addColorStop(0, `rgba(210,175,70,${0.04 * fxAlpha})`);
          beamGrad.addColorStop(1, "rgba(210,175,70,0)");
          ctx.fillStyle = beamGrad; ctx.fillRect(c.x - S * 0.15, c.y - S * 4, S * 0.3, S * 3);

        } else if (domEmo === 'guilt') {
          // Inward-spiraling particles
          const spiralCount = isMobile ? 4 : 7;
          for (let sp = 0; sp < spiralCount; sp++) {
            const sAge = (t * 0.4 + sp * 0.7 + c.phase) % 2.0;
            const sLife = sAge / 2.0;
            const sDist = S * (2.5 - sLife * 2);  // moves inward
            const sAngle = sp * 1.1 + sLife * Math.PI * 3 + c.phase;
            const spx = c.x + Math.cos(sAngle) * sDist;
            const spy = c.y + Math.sin(sAngle) * sDist;
            const sAlpha = Math.sin(sLife * Math.PI) * 0.08 * fxAlpha;
            ctx.beginPath(); ctx.arc(spx, spy, 1.2, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(135,105,105,${sAlpha})`; ctx.fill();
          }
          // Darker inner shadow
          const guiltShadow = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, S * 0.8);
          guiltShadow.addColorStop(0, `rgba(40,30,30,${0.06 * fxAlpha})`);
          guiltShadow.addColorStop(0.6, `rgba(60,45,45,${0.02 * fxAlpha})`);
          guiltShadow.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = guiltShadow; ctx.beginPath(); ctx.arc(c.x, c.y, S * 0.8, 0, Math.PI * 2); ctx.fill();

        } else if (domEmo === 'love') {
          // Warm pulsing expanding aura
          const lovePulse = Math.sin(t * 0.5 + c.phase) * 0.5 + 0.5;
          const loveR = S * (2 + lovePulse * 1.5);
          const loveGlow = ctx.createRadialGradient(c.x, c.y, S * 0.5, c.x, c.y, loveR);
          loveGlow.addColorStop(0, `rgba(215,90,130,${0.04 * fxAlpha})`);
          loveGlow.addColorStop(0.4, `rgba(230,120,150,${0.02 * fxAlpha * lovePulse})`);
          loveGlow.addColorStop(1, "rgba(215,90,130,0)");
          ctx.fillStyle = loveGlow; ctx.beginPath(); ctx.arc(c.x, c.y, loveR, 0, Math.PI * 2); ctx.fill();
          // Floating orbit particles in soft curves
          const orbCount = isMobile ? 4 : 6;
          for (let o = 0; o < orbCount; o++) {
            const oAngle = t * 0.25 + (o / orbCount) * Math.PI * 2 + c.phase;
            const oDist = S * (1.5 + Math.sin(t * 0.4 + o * 1.5) * 0.5);
            const ox = c.x + Math.cos(oAngle) * oDist;
            const oy = c.y + Math.sin(oAngle) * oDist * 0.7;  // elliptical
            ctx.beginPath(); ctx.arc(ox, oy, 1.5 + Math.sin(t + o) * 0.5, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(230,120,160,${0.1 * fxAlpha})`; ctx.fill();
          }

        } else if (domEmo === 'confusion') {
          // Orbiting particles that shift direction unpredictably
          const orbCount = isMobile ? 4 : 8;
          for (let o = 0; o < orbCount; o++) {
            const baseAngle = (o / orbCount) * Math.PI * 2;
            const chaos = Math.sin(t * 1.2 + o * 2.7 + c.phase) * Math.cos(t * 0.8 + o * 1.3) * 1.5;
            const oDist = S * (1.2 + Math.sin(t * 0.7 + o) * 0.4);
            const ox = c.x + Math.cos(baseAngle + chaos + t * 0.3) * oDist;
            const oy = c.y + Math.sin(baseAngle + chaos + t * 0.3) * oDist;
            ctx.beginPath(); ctx.arc(ox, oy, 1.2, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(165,145,195,${0.1 * fxAlpha})`; ctx.fill();
            // Trailing path
            if (!isMobile) {
              const ox2 = c.x + Math.cos(baseAngle + chaos + (t - 0.02) * 0.3) * oDist;
              const oy2 = c.y + Math.sin(baseAngle + chaos + (t - 0.02) * 0.3) * oDist;
              ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(ox2, oy2);
              ctx.strokeStyle = `rgba(165,145,195,${0.04 * fxAlpha})`; ctx.lineWidth = 0.6; ctx.stroke();
            }
          }
          // Tangled web lines
          if (!isMobile) {
            for (let w = 0; w < 3; w++) {
              const a1 = t * 0.2 + w * 2.1 + c.phase, a2 = t * 0.2 + w * 2.1 + 1.5 + c.phase;
              const p1x = c.x + Math.cos(a1) * S * 1.3, p1y = c.y + Math.sin(a1) * S * 1.3;
              const p2x = c.x + Math.cos(a2) * S * 1.3, p2y = c.y + Math.sin(a2) * S * 1.3;
              ctx.beginPath(); ctx.moveTo(p1x, p1y);
              ctx.quadraticCurveTo(c.x + Math.sin(t + w) * S * 0.5, c.y + Math.cos(t + w) * S * 0.5, p2x, p2y);
              ctx.strokeStyle = `rgba(165,145,195,${0.03 * fxAlpha})`; ctx.lineWidth = 0.5; ctx.stroke();
            }
          }

        } else if (domEmo === 'awe') {
          // Expanding cosmic halo with tiny star particles
          const aweHalo = ctx.createRadialGradient(c.x, c.y, S, c.x, c.y, S * 4.5);
          aweHalo.addColorStop(0, `rgba(100,90,185,${0.03 * fxAlpha})`);
          aweHalo.addColorStop(0.3, `rgba(120,100,210,${0.015 * fxAlpha})`);
          aweHalo.addColorStop(0.7, `rgba(80,70,160,${0.006 * fxAlpha})`);
          aweHalo.addColorStop(1, "rgba(100,90,185,0)");
          ctx.fillStyle = aweHalo; ctx.beginPath(); ctx.arc(c.x, c.y, S * 4.5, 0, Math.PI * 2); ctx.fill();
          // Tiny orbiting cosmic stars
          const cosmicCount = isMobile ? 5 : 10;
          for (let cs = 0; cs < cosmicCount; cs++) {
            const csAngle = t * 0.15 + (cs / cosmicCount) * Math.PI * 2 + c.phase;
            const csDist = S * (1.8 + Math.sin(cs * 1.7 + t * 0.2) * 0.8);
            const csx = c.x + Math.cos(csAngle) * csDist;
            const csy = c.y + Math.sin(csAngle * 0.8 + cs * 0.3) * csDist * 0.6;
            const csTwinkle = Math.sin(t * 1.5 + cs * 2.3) * 0.5 + 0.5;
            ctx.beginPath(); ctx.arc(csx, csy, 0.6 + csTwinkle * 0.8, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(180,170,255,${0.08 * fxAlpha * csTwinkle})`; ctx.fill();
          }

        } else if (domEmo === 'envy') {
          // Angular thorny protrusions
          const thornCount = isMobile ? 4 : 6;
          for (let th = 0; th < thornCount; th++) {
            const thAngle = (th / thornCount) * Math.PI * 2 + Math.sin(t * 0.3 + th) * 0.2 + c.phase;
            const thLen = S * (0.8 + Math.sin(t * 0.5 + th * 1.7 + c.phase) * 0.3) * fxAlpha;
            const base = S * 0.85;
            const bx = c.x + Math.cos(thAngle) * base;
            const by = c.y + Math.sin(thAngle) * base;
            const tipx = c.x + Math.cos(thAngle) * (base + thLen);
            const tipy = c.y + Math.sin(thAngle) * (base + thLen);
            const perpAngle = thAngle + Math.PI * 0.5;
            const bw = S * 0.08;
            ctx.beginPath();
            ctx.moveTo(bx + Math.cos(perpAngle) * bw, by + Math.sin(perpAngle) * bw);
            ctx.lineTo(tipx, tipy);
            ctx.lineTo(bx - Math.cos(perpAngle) * bw, by - Math.sin(perpAngle) * bw);
            ctx.closePath();
            ctx.fillStyle = `rgba(80,155,100,${0.06 * fxAlpha})`; ctx.fill();
          }

        } else if (domEmo === 'disgust') {
          // Contracting spiky membrane + repelling visual
          const spikeCount = isMobile ? 6 : 10;
          const disgustPulse = Math.sin(t * 1.2 + c.phase) * 0.1;
          ctx.beginPath();
          for (let sp = 0; sp <= spikeCount * 2; sp++) {
            const spAngle = (sp / (spikeCount * 2)) * Math.PI * 2;
            const isSpike = sp % 2 === 0;
            const spDist = S * (isSpike ? (1.15 + disgustPulse) : (0.95 + disgustPulse));
            const px = c.x + Math.cos(spAngle) * spDist;
            const py = c.y + Math.sin(spAngle) * spDist;
            sp === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
          }
          ctx.closePath();
          ctx.strokeStyle = `rgba(110,135,70,${0.06 * fxAlpha})`; ctx.lineWidth = 0.8; ctx.stroke();
          // Toxic haze
          const toxGrad = ctx.createRadialGradient(c.x, c.y, S, c.x, c.y, S * 2);
          toxGrad.addColorStop(0, `rgba(90,115,50,${0.03 * fxAlpha})`);
          toxGrad.addColorStop(1, "rgba(110,135,70,0)");
          ctx.fillStyle = toxGrad; ctx.beginPath(); ctx.arc(c.x, c.y, S * 2, 0, Math.PI * 2); ctx.fill();
        }
        } // end isLive gate
      });
      animRef.current = requestAnimationFrame(draw);
    };
    draw();
    return () => { running=false; if(animRef.current) cancelAnimationFrame(animRef.current); };
  }, []);

  const getPointerPos = useCallback((e) => {
    const rect = canvasRef.current?.getBoundingClientRect(); if (!rect) return null;
    const touch = e.touches && e.touches.length > 0 ? e.touches[0] : null;
    const clientX = touch ? touch.clientX : e.clientX, clientY = touch ? touch.clientY : e.clientY;
    if (clientX == null || clientY == null) return null;
    return { x: clientX - rect.left, y: clientY - rect.top };
  }, []);
  const updateHit = useCallback((pos) => {
    if (!pos) return; mouseRef.current = pos; let hit = null;
    stateRef.current.forEach(c => { const dx=pos.x-c.x,dy=pos.y-c.y; if(Math.sqrt(dx*dx+dy*dy)<c.size*2.5)hit=c.id; });
    hitRef.current = hit; if (canvasRef.current) canvasRef.current.style.cursor = hit ? "pointer" : "default";
  }, []);
  const handlePointerMove = useCallback(e => updateHit(getPointerPos(e)), [getPointerPos, updateHit]);
  const handlePointerLeave = useCallback(() => { mouseRef.current={x:-999,y:-999}; hitRef.current=null; }, []);
  const handlePointerClick = useCallback(() => { if (hitRef.current != null) onClickRef.current(hitRef.current); }, []);
  const touchStartHit = useRef(null);
  const handleTouchStart = useCallback(e => { updateHit(getPointerPos(e)); touchStartHit.current=hitRef.current; }, [getPointerPos, updateHit]);
  const handleTouchEnd = useCallback(e => {
    if (touchStartHit.current!=null && touchStartHit.current===hitRef.current) { e.preventDefault(); onClickRef.current(touchStartHit.current); }
    touchStartHit.current=null; mouseRef.current={x:-999,y:-999}; hitRef.current=null;
  }, []);

  return (
    <canvas ref={canvasRef} style={{width,height,display:"block",touchAction:"none"}}
      onMouseMove={handlePointerMove} onMouseLeave={handlePointerLeave} onClick={handlePointerClick}
      onTouchStart={handleTouchStart} onTouchMove={e=>updateHit(getPointerPos(e))} onTouchEnd={handleTouchEnd} />
  );
};

/* UI helpers */
const EmotionBar = ({emotionKey, weight}) => {
  if (!EMOTIONS[emotionKey]) return null;
  const {color,label}=EMOTIONS[emotionKey]; const [r,g,b]=color;
  return (
    <div style={{marginBottom:12}}>
      <div style={{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:4}}>
        <div style={{display:"flex",alignItems:"center",gap:7}}>
          <div style={{width:8,height:8,borderRadius:"50%",background:`rgb(${r},${g},${b})`,boxShadow:`0 0 6px rgba(${r},${g},${b},0.35)`,flexShrink:0}}/>
          <span style={{fontSize:12.5,color:"rgba(255,255,255,0.5)",fontFamily:"'DM Sans',sans-serif",fontWeight:300}}>{label}</span>
        </div>
        <span style={{fontSize:12,fontFamily:"'DM Mono',monospace",color:`rgba(${r},${g},${b},0.7)`}}>{Math.round(weight*100)}%</span>
      </div>
      <div style={{width:"100%",height:3,borderRadius:2,background:"rgba(255,255,255,0.025)"}}>
        <div style={{width:`${weight*100}%`,height:"100%",borderRadius:2,background:`linear-gradient(90deg,rgba(${r},${g},${b},0.55),rgba(${r},${g},${b},0.15))`,transition:"width 0.6s ease"}}/>
      </div>
    </div>
  );
};

const GradientBar = ({emotions}) => {
  const entries = Object.entries(emotions).sort((a,b)=>b[1]-a[1]);
  if (!entries.length) return null;
  return (<div style={{width:"100%",height:4,borderRadius:4,overflow:"hidden",display:"flex",opacity:0.7}}>
    {entries.map(([key,weight])=>{if(!EMOTIONS[key])return null;const[r,g,b]=EMOTIONS[key].color;return <div key={key} style={{flex:weight,height:"100%",background:`rgb(${r},${g},${b})`}}/>;})}</div>);
};

function useIsMobile() {
  const [mobile,setMobile]=useState(false);
  useEffect(()=>{const check=()=>setMobile(window.innerWidth<640);check();window.addEventListener("resize",check);return()=>window.removeEventListener("resize",check);},[]);
  return mobile;
}

/* Main */
function EmotionEcosystem() {
  const isMobile = useIsMobile();
  const [entries, setEntries] = useState(()=>{try{const saved=localStorage.getItem("colour_garden_entries");return saved?JSON.parse(saved):[];}catch(e){return[];}});
  const [selectedId,setSelectedId]=useState(null);
  const [showWrite,setShowWrite]=useState(false);
  const [currentText,setCurrentText]=useState("");
  const [liveEmotions,setLiveEmotions]=useState({});
  const containerRef=useRef(null);
  const audioRef=useRef(null);
  const [soundOn,setSoundOn]=useState(false);
  const [canvasSize,setCanvasSize]=useState({w:800,h:600});

  // Audio engine lifecycle
  useEffect(()=>{
    if (!audioRef.current) audioRef.current = createAudioEngine();
    if (soundOn) audioRef.current.start();
    else audioRef.current.stop();
  },[soundOn]);
  // Update ambient when entries change
  useEffect(()=>{
    if (audioRef.current && soundOn) audioRef.current.updateAmbient(entries);
  },[entries, soundOn]);

  useEffect(()=>{try{localStorage.setItem("colour_garden_entries",JSON.stringify(entries));}catch(e){}},[entries]);
  useEffect(()=>{const m=()=>{if(containerRef.current){const r=containerRef.current.getBoundingClientRect();if(r.width>0&&r.height>0)setCanvasSize({w:r.width,h:r.height});}};m();window.addEventListener("resize",m);const tm=setTimeout(m,100);return()=>{window.removeEventListener("resize",m);clearTimeout(tm);};},[]);
  useEffect(()=>{if(currentText.length>15){const to=setTimeout(()=>setLiveEmotions(analyzeEmotions(currentText)),300);return()=>clearTimeout(to);}else setLiveEmotions({});},[currentText]);

  const handleSave=useCallback(()=>{if(currentText.trim().length<10)return;const emotions=analyzeEmotions(currentText);const ne={id:Date.now(),date:new Date().toLocaleDateString("en-US",{month:"short",day:"numeric",year:"numeric"}).toUpperCase(),text:currentText,emotions};setEntries(prev=>[ne,...prev]);if(audioRef.current)audioRef.current.playRelease(emotions);setCurrentText("");setLiveEmotions({});setShowWrite(false);setSelectedId(ne.id);},[currentText]);
  const handleCreatureClick=useCallback(id=>{if(id==="live")return;setSelectedId(prev=>{const next=prev===id?null:id;if(next!=null){const entry=entries.find(e=>e.id===id);if(entry&&audioRef.current)audioRef.current.playTone(entry.emotions);}return next;});setShowWrite(false);},[entries]);

  const creatures=entries.map(e=>({id:e.id,size:getSize(e.text.length),colors:getTopColors(e.emotions),blended:blendColors(e.emotions),emotionCount:Object.keys(e.emotions).length}));
  if(Object.keys(liveEmotions).length>0)creatures.push({id:"live",size:getSize(currentText.length),colors:getTopColors(liveEmotions),blended:blendColors(liveEmotions),emotionCount:Object.keys(liveEmotions).length,isLive:true});

  const selectedEntry=selectedId!=null?entries.find(e=>e.id===selectedId):null;
  const panelEmotions=selectedEntry?Object.entries(selectedEntry.emotions).sort((a,b)=>b[1]-a[1]):[];
  const panelW=isMobile?"100%":350, writeW=isMobile?"100%":440;

  return (
    <div style={{position:"fixed",inset:0,background:"radial-gradient(ellipse at 50% 50%,#0e0e18 0%,#08080f 50%,#060609 100%)",overflow:"hidden"}}>
      <div ref={containerRef} style={{position:"absolute",inset:0}}>
        <EcosystemCanvas creatures={creatures} width={canvasSize.w} height={canvasSize.h} onCreatureClick={handleCreatureClick} selectedId={selectedId}/>
      </div>

      {/* Title */}
      <div style={{position:"absolute",top:0,left:0,right:0,padding:isMobile?"16px 20px":"22px 28px",background:"linear-gradient(to bottom,rgba(10,10,18,0.8) 0%,transparent 100%)",pointerEvents:"none",zIndex:10}}>
        <h1 style={{margin:0,fontSize:isMobile?16:18,fontWeight:300,fontFamily:"'Cormorant Garamond',serif",color:"rgba(255,255,255,0.4)",letterSpacing:1}}>colour garden</h1>
        {entries.length>0 && <div style={{fontSize:9,fontFamily:"'DM Mono',monospace",color:"rgba(255,255,255,0.1)",letterSpacing:2,marginTop:4}}>{entries.length} moment{entries.length!==1?"s":""} growing</div>}
      </div>

      {/* Sound toggle */}
      <button onClick={()=>setSoundOn(p=>!p)} style={{position:"absolute",top:isMobile?16:22,right:isMobile?16:24,zIndex:12,background:"rgba(255,255,255,0.03)",border:"1px solid rgba(255,255,255,0.05)",borderRadius:20,padding:isMobile?"6px 12px":"7px 14px",cursor:"pointer",display:"flex",alignItems:"center",gap:6,backdropFilter:"blur(8px)",WebkitBackdropFilter:"blur(8px)"}}>
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke={soundOn?"rgba(255,255,255,0.35)":"rgba(255,255,255,0.12)"} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
          {soundOn ? (<><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></>) : (<><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></>)}
        </svg>
        <span style={{fontSize:8,fontFamily:"'DM Mono',monospace",color:soundOn?"rgba(255,255,255,0.25)":"rgba(255,255,255,0.1)",letterSpacing:1.5}}>{soundOn?"on":"off"}</span>
      </button>

      {/* Welcome */}
      {entries.length===0 && !showWrite && (
        <div style={{position:"absolute",inset:0,display:"flex",alignItems:"center",justifyContent:"center",zIndex:11,pointerEvents:"none",animation:"fadeIn 1.5s ease"}}>
          <div style={{textAlign:"center",maxWidth:340,padding:"0 24px"}}>
            <div style={{fontSize:isMobile?28:34,fontFamily:"'Cormorant Garamond',serif",fontWeight:300,fontStyle:"italic",color:"rgba(255,255,255,0.25)",lineHeight:1.4,marginBottom:16}}>welcome to<br/>your colour garden</div>
            <div style={{width:40,height:1,background:"rgba(255,255,255,0.06)",margin:"0 auto 16px"}}/>
            <div style={{fontSize:isMobile?12:13,fontFamily:"'DM Sans',sans-serif",fontWeight:300,color:"rgba(255,255,255,0.12)",lineHeight:1.8}}>write what you feel and watch it bloom</div>
          </div>
        </div>
      )}

      {/* Write */}
      <div style={{position:"absolute",bottom:isMobile?16:28,left:"50%",transform:"translateX(-50%)",zIndex:20,display:"flex",flexDirection:"column",alignItems:"center",gap:10,width:isMobile?"calc(100% - 32px)":"auto",maxWidth:480}}>
        {showWrite && (
          <div style={{width:writeW,maxWidth:"100%",background:"rgba(12,12,20,0.94)",backdropFilter:"blur(24px)",WebkitBackdropFilter:"blur(24px)",borderRadius:20,border:"1px solid rgba(255,255,255,0.05)",padding:isMobile?16:22,boxShadow:"0 20px 60px rgba(0,0,0,0.5)",animation:"slideUp 0.35s ease"}}>
            <textarea value={currentText} onChange={e=>setCurrentText(e.target.value)} placeholder="how are you feeling right now?" rows={isMobile?4:5}
              style={{width:"100%",background:"transparent",border:"none",color:"rgba(255,255,255,0.65)",fontSize:isMobile?15:14,fontFamily:"'DM Sans',sans-serif",fontWeight:300,lineHeight:1.8,resize:"none",padding:0,margin:0}}/>
            <div style={{display:"flex",justifyContent:"space-between",alignItems:"center",marginTop:10,gap:8}}>
              <div style={{display:"flex",gap:5,alignItems:"center",flexShrink:0}}>
                {Object.entries(liveEmotions).sort((a,b)=>b[1]-a[1]).slice(0,5).map(([key])=>{if(!EMOTIONS[key])return null;const[cr,cg,cb]=EMOTIONS[key].color;return <div key={key} style={{width:8,height:8,borderRadius:"50%",background:`rgb(${cr},${cg},${cb})`,boxShadow:`0 0 8px rgba(${cr},${cg},${cb},0.4)`,transition:"all 0.4s ease"}}/>;})}</div>
              <div style={{display:"flex",gap:8,flexShrink:0}}>
                <button onClick={()=>{setShowWrite(false);setCurrentText("");setLiveEmotions({});}} style={{background:"transparent",border:"1px solid rgba(255,255,255,0.06)",color:"rgba(255,255,255,0.25)",borderRadius:16,padding:"6px 16px",fontSize:10,cursor:"pointer",fontFamily:"'DM Mono',monospace",letterSpacing:1}}>cancel</button>
                {currentText.length>10 && <button onClick={handleSave} style={{background:"rgba(255,255,255,0.06)",border:"1px solid rgba(255,255,255,0.08)",color:"rgba(255,255,255,0.5)",borderRadius:16,padding:"6px 20px",fontSize:10,cursor:"pointer",fontFamily:"'DM Mono',monospace",letterSpacing:1}}>release</button>}
              </div>
            </div>
          </div>
        )}
        {!showWrite && <button onClick={()=>{setShowWrite(true);setSelectedId(null);}} style={{background:"rgba(255,255,255,0.03)",backdropFilter:"blur(12px)",WebkitBackdropFilter:"blur(12px)",border:"1px solid rgba(255,255,255,0.06)",color:"rgba(255,255,255,0.3)",borderRadius:24,padding:"11px 30px",fontSize:11,cursor:"pointer",fontFamily:"'DM Mono',monospace",letterSpacing:2}}>+ new entry</button>}
        {!showWrite&&!selectedId&&entries.length>0 && <div style={{fontSize:9,fontFamily:"'DM Mono',monospace",color:"rgba(255,255,255,0.07)",letterSpacing:1.5,animation:"fadeIn 1s ease",textAlign:"center"}}>tap an organism to read its story</div>}
      </div>

      {/* Detail panel */}
      {selectedEntry && (
        <div key={selectedEntry.id} style={isMobile?{position:"absolute",left:0,right:0,bottom:0,maxHeight:"70vh",background:"rgba(10,10,16,0.95)",backdropFilter:"blur(30px)",WebkitBackdropFilter:"blur(30px)",borderTop:"1px solid rgba(255,255,255,0.04)",borderRadius:"20px 20px 0 0",zIndex:25,overflowY:"hidden",animation:"slideUpMobile 0.4s ease",display:"flex",flexDirection:"column"}:{position:"absolute",top:0,right:0,bottom:0,width:panelW,background:"rgba(10,10,16,0.92)",backdropFilter:"blur(30px)",WebkitBackdropFilter:"blur(30px)",borderLeft:"1px solid rgba(255,255,255,0.03)",zIndex:15,padding:"36px 28px",overflowY:"auto",animation:"slideIn 0.4s ease",display:"flex",flexDirection:"column"}}>
          {isMobile&&(<div style={{padding:"16px 20px 8px",flexShrink:0,display:"flex",justifyContent:"center",position:"relative"}}><div style={{width:36,height:4,borderRadius:2,background:"rgba(255,255,255,0.1)"}}/><button onClick={()=>setSelectedId(null)} style={{position:"absolute",top:12,right:16,background:"rgba(255,255,255,0.05)",border:"none",color:"rgba(255,255,255,0.3)",width:30,height:30,borderRadius:"50%",cursor:"pointer",fontSize:15,display:"flex",alignItems:"center",justifyContent:"center"}}>{"×"}</button></div>)}
          {!isMobile&&<button onClick={()=>setSelectedId(null)} style={{position:"absolute",top:20,right:20,background:"rgba(255,255,255,0.03)",border:"none",color:"rgba(255,255,255,0.25)",width:28,height:28,borderRadius:"50%",cursor:"pointer",fontSize:14,display:"flex",alignItems:"center",justifyContent:"center",flexShrink:0}}>{"×"}</button>}

          <div style={isMobile?{overflowY:"auto",padding:"8px 20px 24px",flex:1,WebkitOverflowScrolling:"touch"}:{flex:1,display:"flex",flexDirection:"column"}}>
            <div style={{marginBottom:16}}>
              <div style={{fontSize:9,fontFamily:"'DM Mono',monospace",color:"rgba(255,255,255,0.15)",letterSpacing:2,marginBottom:10}}>{selectedEntry.date}</div>
              <GradientBar emotions={selectedEntry.emotions}/>
            </div>
            <div style={{padding:"16px 0",borderTop:"1px solid rgba(255,255,255,0.03)",borderBottom:"1px solid rgba(255,255,255,0.03)",marginBottom:18}}>
              <p style={{margin:0,fontSize:isMobile?14.5:14,lineHeight:1.9,color:"rgba(255,255,255,0.5)",fontFamily:"'DM Sans',sans-serif",fontWeight:300}}>{selectedEntry.text}</p>
            </div>
            <div style={{fontSize:9,fontFamily:"'DM Mono',monospace",color:"rgba(255,255,255,0.12)",letterSpacing:2,marginBottom:14}}>what was felt</div>
            {panelEmotions.map(([key,weight])=><EmotionBar key={key} emotionKey={key} weight={weight}/>)}
            <div style={{marginTop:12}}>
              <div style={{fontSize:9,fontFamily:"'DM Mono',monospace",color:"rgba(255,255,255,0.12)",letterSpacing:2,marginBottom:8}}>blended colour</div>
              <div style={{height:24,borderRadius:12,background:(()=>{const tops=panelEmotions.slice(0,4);if(tops.length===0)return"rgba(80,80,100,0.2)";if(tops.length<2){const c2=EMOTIONS[tops[0]?.[0]]?.color||[80,80,100];return`linear-gradient(135deg,rgba(${c2[0]},${c2[1]},${c2[2]},0.4),rgba(${c2[0]},${c2[1]},${c2[2]},0.1))`;}return`linear-gradient(135deg,${tops.map(([key],i)=>{const c2=EMOTIONS[key]?.color||[80,80,100];return`rgba(${c2[0]},${c2[1]},${c2[2]},0.4) ${(i/(tops.length-1))*100}%`;}).join(",")})`;})()}}/>
            </div>
            <button onClick={()=>{setEntries(prev=>prev.filter(e=>e.id!==selectedId));setSelectedId(null);}} style={{marginTop:isMobile?20:"auto",paddingTop:isMobile?12:28,paddingBottom:isMobile?8:0,background:"transparent",border:"none",color:"rgba(255,255,255,0.08)",fontSize:9,fontFamily:"'DM Mono',monospace",letterSpacing:1,cursor:"pointer",textAlign:"center",flexShrink:0}}>let go of this moment</button>
          </div>
        </div>
      )}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<EmotionEcosystem/>);
</script>
<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js').catch(() => {});
}
</script>
</body>
</html>
